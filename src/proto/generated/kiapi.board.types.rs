// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetCode {
    #[prost(int32, tag = "1")]
    pub value: i32,
}
/// Describes a copper item's net
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Net {
    /// A unique code representing this net
    #[prost(message, optional, tag = "1")]
    pub code: ::core::option::Option<NetCode>,
    /// Human-readable net name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a track segment on a board
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Track {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "4")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "6")]
    pub layer: i32,
    #[prost(message, optional, tag = "7")]
    pub net: ::core::option::Option<Net>,
}
/// Represents an arc track (not a PCB_SHAPE in arc shape)
/// Arc tracks in KiCad store start, midpoint, and end.
/// All other values (center point, angles, etc) are inferred.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Arc {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    /// Arc midpoint
    #[prost(message, optional, tag = "3")]
    pub mid: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "5")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "6")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "7")]
    pub layer: i32,
    #[prost(message, optional, tag = "8")]
    pub net: ::core::option::Option<Net>,
}
/// Which corners are chamfered in a PSS_CHAMFEREDRECT
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChamferedRectCorners {
    #[prost(bool, tag = "1")]
    pub top_left: bool,
    #[prost(bool, tag = "2")]
    pub top_right: bool,
    #[prost(bool, tag = "3")]
    pub bottom_left: bool,
    #[prost(bool, tag = "4")]
    pub bottom_right: bool,
}
/// Controls for how copper zones connect to a pad
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ZoneConnectionSettings {
    #[prost(enumeration = "ZoneConnectionStyle", tag = "1")]
    pub zone_connection: i32,
    #[prost(message, optional, tag = "2")]
    pub thermal_spokes: ::core::option::Option<ThermalSpokeSettings>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SolderMaskOverrides {
    /// Solder mask expansion/contraction
    #[prost(message, optional, tag = "1")]
    pub solder_mask_margin: ::core::option::Option<
        super::super::common::types::Distance,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SolderPasteOverrides {
    /// Solder paste expansion/contraction
    #[prost(message, optional, tag = "1")]
    pub solder_paste_margin: ::core::option::Option<
        super::super::common::types::Distance,
    >,
    /// Solder paste expansion/contraction ratio
    #[prost(message, optional, tag = "2")]
    pub solder_paste_margin_ratio: ::core::option::Option<
        super::super::common::types::Ratio,
    >,
}
/// The defintion of a padstack on a single layer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadStackLayer {
    /// The board layer of this padstack entry.  For Front/Inner/Back padstacks, In1_Cu is used to represent inner layers.
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub layer: i32,
    /// The shape of the pad on this layer
    #[prost(enumeration = "PadStackShape", tag = "2")]
    pub shape: i32,
    /// The size (x and y) of the shape on this layer
    #[prost(message, optional, tag = "3")]
    pub size: ::core::option::Option<super::super::common::types::Vector2>,
    /// How much to round the corners of the shape by, as a fraction of min(size.x, size.y)
    /// Only used for PSS_ROUNDRECT or PSS_CHAMFEREDRECT
    #[prost(double, tag = "4")]
    pub corner_rounding_ratio: f64,
    /// How much to round the corners of the shape by, as a fraction of min(size.x, size.y)
    /// Only used for PSS_CHAMFEREDRECT
    #[prost(double, tag = "5")]
    pub chamfer_ratio: f64,
    #[prost(message, optional, tag = "6")]
    pub chamfered_corners: ::core::option::Option<ChamferedRectCorners>,
    #[prost(message, repeated, tag = "7")]
    pub custom_shapes: ::prost::alloc::vec::Vec<BoardGraphicShape>,
    /// If shape == PSS_CUSTOM, defines the shape of the anchor (only PSS_CIRCLE and PSS_RECTANGLE supported at present)
    #[prost(enumeration = "PadStackShape", tag = "8")]
    pub custom_anchor_shape: i32,
    /// Reserved for future use -- at the moment, zone connection settings are not per-layer
    #[prost(message, optional, tag = "9")]
    pub zone_settings: ::core::option::Option<ZoneConnectionSettings>,
    /// The difference in side length between the short and long pads in a trapezoid.  Only one of x or y may be nonzero.
    /// Only used for PSS_TRAPEZOID
    #[prost(message, optional, tag = "10")]
    pub trapezoid_delta: ::core::option::Option<super::super::common::types::Vector2>,
    /// The offset of the center of this shape from the center of the pad (which is defined as the hole center)
    #[prost(message, optional, tag = "11")]
    pub offset: ::core::option::Option<super::super::common::types::Vector2>,
}
/// Properties for the outer technical layers of a padstack on the top or bottom of the stack
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PadStackOuterLayer {
    #[prost(enumeration = "SolderMaskMode", tag = "1")]
    pub solder_mask_mode: i32,
    #[prost(enumeration = "SolderPasteMode", tag = "2")]
    pub solder_paste_mode: i32,
    /// NOTE: At present, KiCad does not support different solder mask expansion settings for the top and bottom layers
    #[prost(message, optional, tag = "3")]
    pub solder_mask_settings: ::core::option::Option<SolderMaskOverrides>,
    /// NOTE: At present, KiCad does not support different solder paste expansion settings for the top and bottom layers
    #[prost(message, optional, tag = "4")]
    pub solder_paste_settings: ::core::option::Option<SolderPasteOverrides>,
    #[prost(enumeration = "ViaPluggingMode", tag = "5")]
    pub plugging_mode: i32,
    #[prost(enumeration = "ViaCoveringMode", tag = "6")]
    pub covering_mode: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DrillProperties {
    /// Lowest (closest to F_Cu) layer this drill exists on.
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub start_layer: i32,
    /// Highest (closest to B_Cu) layer this drill exists on.
    #[prost(enumeration = "BoardLayer", tag = "2")]
    pub end_layer: i32,
    /// The diameter, in x and y, of the pad's drilled hole, if this pad has a hole.
    /// x and y will be the same value if the hole is round.
    #[prost(message, optional, tag = "3")]
    pub diameter: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(enumeration = "DrillShape", tag = "4")]
    pub shape: i32,
    #[prost(enumeration = "ViaDrillCappingMode", tag = "5")]
    pub capped: i32,
    #[prost(enumeration = "ViaDrillFillingMode", tag = "6")]
    pub filled: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostMachiningProperties {
    #[prost(enumeration = "ViaDrillPostMachiningMode", tag = "1")]
    pub mode: i32,
    #[prost(int32, tag = "2")]
    pub size: i32,
    #[prost(int32, tag = "3")]
    pub depth: i32,
    #[prost(int32, tag = "4")]
    pub angle: i32,
}
/// A pad stack definition for a multilayer pad or via.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadStack {
    /// What type of pad stack this represents.
    #[prost(enumeration = "PadStackType", tag = "1")]
    pub r#type: i32,
    /// The set of board layers this padstack has a definition for
    #[prost(enumeration = "BoardLayer", repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
    /// Properties of the drilled hole in this padstack, if it has one
    #[prost(message, optional, tag = "3")]
    pub drill: ::core::option::Option<DrillProperties>,
    /// How to treat pad shapes on unconnected layers.
    #[prost(enumeration = "UnconnectedLayerRemoval", tag = "4")]
    pub unconnected_layer_removal: i32,
    #[prost(message, repeated, tag = "5")]
    pub copper_layers: ::prost::alloc::vec::Vec<PadStackLayer>,
    /// The overall rotation of this padstack (affects all layers)
    #[prost(message, optional, tag = "6")]
    pub angle: ::core::option::Option<super::super::common::types::Angle>,
    /// Solder mask and paste settings for the front
    #[prost(message, optional, tag = "7")]
    pub front_outer_layers: ::core::option::Option<PadStackOuterLayer>,
    /// Solder mask and paste settings for the back
    #[prost(message, optional, tag = "8")]
    pub back_outer_layers: ::core::option::Option<PadStackOuterLayer>,
    /// Controls for how copper zones connect to the padstack
    #[prost(message, optional, tag = "9")]
    pub zone_settings: ::core::option::Option<ZoneConnectionSettings>,
    /// Optional secondary drill hit for backdrilling
    #[prost(message, optional, tag = "10")]
    pub secondary_drill: ::core::option::Option<DrillProperties>,
    /// Optional tertiary drill hit for backdrilling
    #[prost(message, optional, tag = "11")]
    pub tertiary_drill: ::core::option::Option<DrillProperties>,
    #[prost(message, optional, tag = "12")]
    pub front_post_machining: ::core::option::Option<PostMachiningProperties>,
    #[prost(message, optional, tag = "13")]
    pub back_post_machining: ::core::option::Option<PostMachiningProperties>,
}
/// Represents a via
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Via {
    /// The unique identifier of the via
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    /// The location of the via's center point
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    /// The pad stack definition for this via.
    #[prost(message, optional, tag = "3")]
    pub pad_stack: ::core::option::Option<PadStack>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "4")]
    pub locked: i32,
    #[prost(message, optional, tag = "5")]
    pub net: ::core::option::Option<Net>,
    #[prost(enumeration = "ViaType", tag = "6")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardGraphicShape {
    #[prost(message, optional, tag = "1")]
    pub shape: ::core::option::Option<super::super::common::types::GraphicShape>,
    #[prost(enumeration = "BoardLayer", tag = "2")]
    pub layer: i32,
    #[prost(message, optional, tag = "3")]
    pub net: ::core::option::Option<Net>,
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
}
/// A board-specific text object, existing on a board layer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardText {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub text: ::core::option::Option<super::super::common::types::Text>,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(bool, tag = "4")]
    pub knockout: bool,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
}
/// A board-specific textbox, existing on a board layer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardTextBox {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub textbox: ::core::option::Option<super::super::common::types::TextBox>,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "4")]
    pub locked: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThermalSpokeSettings {
    #[prost(message, optional, tag = "1")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(message, optional, tag = "3")]
    pub gap: ::core::option::Option<super::super::common::types::Distance>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SymbolPinInfo {
    /// The pin name for the associated symbol pin, if one exists
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The electrical type of the associated symbol pin, if one exists (EPT_UNKNOWN if not)
    #[prost(enumeration = "super::super::common::types::ElectricalPinType", tag = "2")]
    pub r#type: i32,
    /// True if the pin is attached to a no-connect marker in the schematic
    #[prost(bool, tag = "3")]
    pub no_connect: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pad {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "2")]
    pub locked: i32,
    #[prost(string, tag = "3")]
    pub number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub net: ::core::option::Option<Net>,
    #[prost(enumeration = "PadType", tag = "5")]
    pub r#type: i32,
    #[prost(message, optional, tag = "6")]
    pub pad_stack: ::core::option::Option<PadStack>,
    /// A pad's position is always relative to the parent footprint's origin
    #[prost(message, optional, tag = "7")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    /// Copper-to-copper clearance override
    #[prost(message, optional, tag = "8")]
    pub copper_clearance_override: ::core::option::Option<
        super::super::common::types::Distance,
    >,
    /// Since: 9.0.4
    #[prost(message, optional, tag = "9")]
    pub pad_to_die_length: ::core::option::Option<super::super::common::types::Distance>,
    /// Information about the associated symbol pin, if one exists
    /// Since: 9.0.7
    #[prost(message, optional, tag = "10")]
    pub symbol_pin: ::core::option::Option<SymbolPinInfo>,
    /// Since: 10.0.0
    #[prost(message, optional, tag = "11")]
    pub pad_to_die_delay: ::core::option::Option<super::super::common::types::Time>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HatchFillSettings {
    #[prost(message, optional, tag = "1")]
    pub thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "2")]
    pub gap: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(double, tag = "4")]
    pub hatch_smoothing_ratio: f64,
    #[prost(double, tag = "5")]
    pub hatch_hole_min_area_ratio: f64,
    #[prost(enumeration = "ZoneHatchFillBorderMode", tag = "6")]
    pub border_mode: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TeardropSettings {
    #[prost(enumeration = "TeardropType", tag = "1")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopperZoneSettings {
    #[prost(message, optional, tag = "1")]
    pub connection: ::core::option::Option<ZoneConnectionSettings>,
    #[prost(message, optional, tag = "2")]
    pub clearance: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "3")]
    pub min_thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "IslandRemovalMode", tag = "4")]
    pub island_mode: i32,
    #[prost(uint64, tag = "5")]
    pub min_island_area: u64,
    #[prost(enumeration = "ZoneFillMode", tag = "6")]
    pub fill_mode: i32,
    #[prost(message, optional, tag = "7")]
    pub hatch_settings: ::core::option::Option<HatchFillSettings>,
    #[prost(message, optional, tag = "8")]
    pub net: ::core::option::Option<Net>,
    #[prost(message, optional, tag = "9")]
    pub teardrop: ::core::option::Option<TeardropSettings>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RuleAreaSettings {
    #[prost(bool, tag = "1")]
    pub keepout_copper: bool,
    #[prost(bool, tag = "2")]
    pub keepout_vias: bool,
    #[prost(bool, tag = "3")]
    pub keepout_tracks: bool,
    #[prost(bool, tag = "4")]
    pub keepout_pads: bool,
    #[prost(bool, tag = "5")]
    pub keepout_footprints: bool,
    #[prost(bool, tag = "6")]
    pub placement_enabled: bool,
    #[prost(enumeration = "PlacementRuleSourceType", tag = "7")]
    pub placement_source_type: i32,
    #[prost(string, tag = "8")]
    pub placement_source: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneBorderSettings {
    #[prost(enumeration = "ZoneBorderStyle", tag = "1")]
    pub style: i32,
    #[prost(message, optional, tag = "2")]
    pub pitch: ::core::option::Option<super::super::common::types::Distance>,
}
/// The set of filled polygons of a zone on a single board layer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneFilledPolygons {
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub layer: i32,
    #[prost(message, optional, tag = "2")]
    pub shapes: ::core::option::Option<super::super::common::types::PolySet>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneLayerProperties {
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub layer: i32,
    #[prost(message, optional, tag = "2")]
    pub hatching_offset: ::core::option::Option<super::super::common::types::Vector2>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "ZoneType", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "BoardLayer", repeated, tag = "3")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub outline: ::core::option::Option<super::super::common::types::PolySet>,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub priority: u32,
    #[prost(bool, tag = "9")]
    pub filled: bool,
    #[prost(message, repeated, tag = "10")]
    pub filled_polygons: ::prost::alloc::vec::Vec<ZoneFilledPolygons>,
    #[prost(message, optional, tag = "11")]
    pub border: ::core::option::Option<ZoneBorderSettings>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "12")]
    pub locked: i32,
    #[prost(message, repeated, tag = "13")]
    pub layer_properties: ::prost::alloc::vec::Vec<ZoneLayerProperties>,
    #[prost(oneof = "zone::Settings", tags = "6, 7")]
    pub settings: ::core::option::Option<zone::Settings>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Settings {
        #[prost(message, tag = "6")]
        CopperSettings(super::CopperZoneSettings),
        #[prost(message, tag = "7")]
        RuleAreaSettings(super::RuleAreaSettings),
    }
}
/// An aligned dimension is drawn parallel to the line segment between the start and end points
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AlignedDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    /// Perpendicular distance from dimension endpoints to crossbar
    #[prost(message, optional, tag = "3")]
    pub height: ::core::option::Option<super::super::common::types::Distance>,
    /// Length of extension lines past the crossbar
    #[prost(message, optional, tag = "4")]
    pub extension_height: ::core::option::Option<super::super::common::types::Distance>,
}
/// An orthogonal dimension is drawn parallel to the X or Y axis of the coordinate system
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrthogonalDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    /// Perpendicular distance from dimension endpoints to crossbar
    #[prost(message, optional, tag = "3")]
    pub height: ::core::option::Option<super::super::common::types::Distance>,
    /// Length of extension lines past the crossbar
    #[prost(message, optional, tag = "4")]
    pub extension_height: ::core::option::Option<super::super::common::types::Distance>,
    /// Which axis the dimension is parallel to
    #[prost(enumeration = "super::super::common::types::AxisAlignment", tag = "5")]
    pub alignment: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RadialDimensionAttributes {
    /// The center of the dimensioned circle or arc
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<super::super::common::types::Vector2>,
    /// A point on the radius of the circle or arc
    #[prost(message, optional, tag = "2")]
    pub radius_point: ::core::option::Option<super::super::common::types::Vector2>,
    /// The distance from radius_point to draw the first segment of the leader line.
    /// The second segment is drawn from the end of the first segment to the text position.
    #[prost(message, optional, tag = "3")]
    pub leader_length: ::core::option::Option<super::super::common::types::Distance>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaderDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(enumeration = "DimensionTextBorderStyle", tag = "3")]
    pub border_style: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CenterDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<super::super::common::types::Vector2>,
    /// A point on the end of one of the four radial spokes drawn from the center point
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
}
/// A dimension in KiCad is a special type of text object.
/// To know the visual appearance of the dimension as rendered by KiCad, use GetTextAsShapes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dimension {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "2")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<super::super::common::types::Text>,
    #[prost(bool, tag = "10")]
    pub override_text_enabled: bool,
    #[prost(string, tag = "11")]
    pub override_text: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub suffix: ::prost::alloc::string::String,
    #[prost(enumeration = "DimensionUnit", tag = "14")]
    pub unit: i32,
    #[prost(enumeration = "DimensionUnitFormat", tag = "15")]
    pub unit_format: i32,
    #[prost(enumeration = "DimensionArrowDirection", tag = "16")]
    pub arrow_direction: i32,
    #[prost(enumeration = "DimensionPrecision", tag = "17")]
    pub precision: i32,
    #[prost(bool, tag = "18")]
    pub suppress_trailing_zeroes: bool,
    #[prost(message, optional, tag = "19")]
    pub line_thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "20")]
    pub arrow_length: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "21")]
    pub extension_offset: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "DimensionTextPosition", tag = "22")]
    pub text_position: i32,
    #[prost(bool, tag = "23")]
    pub keep_text_aligned: bool,
    #[prost(oneof = "dimension::DimensionStyle", tags = "5, 6, 7, 8, 9")]
    pub dimension_style: ::core::option::Option<dimension::DimensionStyle>,
}
/// Nested message and enum types in `Dimension`.
pub mod dimension {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DimensionStyle {
        #[prost(message, tag = "5")]
        Aligned(super::AlignedDimensionAttributes),
        #[prost(message, tag = "6")]
        Orthogonal(super::OrthogonalDimensionAttributes),
        #[prost(message, tag = "7")]
        Radial(super::RadialDimensionAttributes),
        #[prost(message, tag = "8")]
        Leader(super::LeaderDimensionAttributes),
        #[prost(message, tag = "9")]
        Center(super::CenterDimensionAttributes),
    }
}
/// TODO
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReferenceImage {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FieldId {
    #[prost(int32, tag = "1")]
    pub id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<FieldId>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub text: ::core::option::Option<BoardText>,
    /// Since 9.0.1
    #[prost(bool, tag = "4")]
    pub visible: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FootprintAttributes {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub keywords: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub not_in_schematic: bool,
    #[prost(bool, tag = "4")]
    pub exclude_from_position_files: bool,
    #[prost(bool, tag = "5")]
    pub exclude_from_bill_of_materials: bool,
    #[prost(bool, tag = "6")]
    pub exempt_from_courtyard_requirement: bool,
    #[prost(bool, tag = "7")]
    pub do_not_populate: bool,
    #[prost(enumeration = "FootprintMountingStyle", tag = "8")]
    pub mounting_style: i32,
    /// Since: 9.0.7
    #[prost(bool, tag = "9")]
    pub allow_soldermask_bridges: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetTieDefinition {
    #[prost(string, repeated, tag = "1")]
    pub pad_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FootprintDesignRuleOverrides {
    #[prost(message, optional, tag = "1")]
    pub solder_mask: ::core::option::Option<SolderMaskOverrides>,
    #[prost(message, optional, tag = "2")]
    pub solder_paste: ::core::option::Option<SolderPasteOverrides>,
    #[prost(message, optional, tag = "3")]
    pub copper_clearance: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "ZoneConnectionStyle", tag = "4")]
    pub zone_connection: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Footprint3DModel {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    /// Scaling factor along each axis
    #[prost(message, optional, tag = "2")]
    pub scale: ::core::option::Option<super::super::common::types::Vector3D>,
    /// Rotation around each axis, in degrees
    #[prost(message, optional, tag = "3")]
    pub rotation: ::core::option::Option<super::super::common::types::Vector3D>,
    /// Offset from footprint center
    #[prost(message, optional, tag = "4")]
    pub offset: ::core::option::Option<super::super::common::types::Vector3D>,
    #[prost(bool, tag = "5")]
    pub visible: bool,
    #[prost(double, tag = "6")]
    pub opacity: f64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JumperGroup {
    #[prost(string, repeated, tag = "1")]
    pub pad_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JumperSettings {
    /// / If true, duplicate pad names in this footprint are jumpered together
    #[prost(bool, tag = "1")]
    pub duplicate_names_are_jumpered: bool,
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<JumperGroup>,
}
/// A footprint definition (i.e. what would be in a library)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Footprint {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::LibraryIdentifier>,
    #[prost(message, optional, tag = "2")]
    pub anchor: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<FootprintAttributes>,
    #[prost(message, optional, tag = "4")]
    pub overrides: ::core::option::Option<FootprintDesignRuleOverrides>,
    #[prost(message, repeated, tag = "5")]
    pub net_ties: ::prost::alloc::vec::Vec<NetTieDefinition>,
    #[prost(enumeration = "BoardLayer", repeated, tag = "6")]
    pub private_layers: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "7")]
    pub reference_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "8")]
    pub value_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "9")]
    pub datasheet_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "10")]
    pub description_field: ::core::option::Option<Field>,
    /// All footprint items except for mandatory fields
    #[prost(message, repeated, tag = "11")]
    pub items: ::prost::alloc::vec::Vec<::prost_types::Any>,
    #[prost(message, optional, tag = "12")]
    pub jumpers: ::core::option::Option<JumperSettings>,
}
/// An instance of a footprint on a board
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FootprintInstance {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(enumeration = "BoardLayer", tag = "4")]
    pub layer: i32,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
    #[prost(message, optional, tag = "6")]
    pub definition: ::core::option::Option<Footprint>,
    #[prost(message, optional, tag = "7")]
    pub reference_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "8")]
    pub value_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "9")]
    pub datasheet_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "10")]
    pub description_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "11")]
    pub attributes: ::core::option::Option<FootprintAttributes>,
    #[prost(message, optional, tag = "12")]
    pub overrides: ::core::option::Option<FootprintDesignRuleOverrides>,
    /// The sheet path to the associated symbol for this footprint instance, if one exists
    #[prost(message, optional, tag = "13")]
    pub symbol_path: ::core::option::Option<super::super::common::types::SheetPath>,
    /// The name of the hierarchical sheet the associated symbol for this footprint exists on,
    /// or the empty string if there is no associated symbol
    /// Since: 9.0.7
    #[prost(string, tag = "14")]
    pub symbol_sheet_name: ::prost::alloc::string::String,
    /// The filename of the hierarchical sheet the associated symbol for this footprint exists on,
    /// or the empty string if there is no associated symbol
    /// Since: 9.0.7
    #[prost(string, tag = "15")]
    pub symbol_sheet_filename: ::prost::alloc::string::String,
    /// The the footprint filters given by the symbol this footprint is associated with,
    /// or the empty string if there is no associated symbol
    /// Since: 9.0.7
    #[prost(string, tag = "16")]
    pub symbol_footprint_filters: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoardLayer {
    BlUnknown = 0,
    BlUndefined = 1,
    BlUnselected = 2,
    BlFCu = 3,
    BlIn1Cu = 4,
    BlIn2Cu = 5,
    BlIn3Cu = 6,
    BlIn4Cu = 7,
    BlIn5Cu = 8,
    BlIn6Cu = 9,
    BlIn7Cu = 10,
    BlIn8Cu = 11,
    BlIn9Cu = 12,
    BlIn10Cu = 13,
    BlIn11Cu = 14,
    BlIn12Cu = 15,
    BlIn13Cu = 16,
    BlIn14Cu = 17,
    BlIn15Cu = 18,
    BlIn16Cu = 19,
    BlIn17Cu = 20,
    BlIn18Cu = 21,
    BlIn19Cu = 22,
    BlIn20Cu = 23,
    BlIn21Cu = 24,
    BlIn22Cu = 25,
    BlIn23Cu = 26,
    BlIn24Cu = 27,
    BlIn25Cu = 28,
    BlIn26Cu = 29,
    BlIn27Cu = 30,
    BlIn28Cu = 31,
    BlIn29Cu = 32,
    BlIn30Cu = 33,
    BlBCu = 34,
    BlBAdhes = 35,
    BlFAdhes = 36,
    BlBPaste = 37,
    BlFPaste = 38,
    BlBSilkS = 39,
    BlFSilkS = 40,
    BlBMask = 41,
    BlFMask = 42,
    BlDwgsUser = 43,
    BlCmtsUser = 44,
    BlEco1User = 45,
    BlEco2User = 46,
    BlEdgeCuts = 47,
    BlMargin = 48,
    BlBCrtYd = 49,
    BlFCrtYd = 50,
    BlBFab = 51,
    BlFFab = 52,
    BlUser1 = 53,
    BlUser2 = 54,
    BlUser3 = 55,
    BlUser4 = 56,
    BlUser5 = 57,
    BlUser6 = 58,
    BlUser7 = 59,
    BlUser8 = 60,
    BlUser9 = 61,
    BlRescue = 62,
    BlUser10 = 63,
    BlUser11 = 64,
    BlUser12 = 65,
    BlUser13 = 66,
    BlUser14 = 67,
    BlUser15 = 68,
    BlUser16 = 69,
    BlUser17 = 70,
    BlUser18 = 71,
    BlUser19 = 72,
    BlUser20 = 73,
    BlUser21 = 74,
    BlUser22 = 75,
    BlUser23 = 76,
    BlUser24 = 77,
    BlUser25 = 78,
    BlUser26 = 79,
    BlUser27 = 80,
    BlUser28 = 81,
    BlUser29 = 82,
    BlUser30 = 83,
    BlUser31 = 84,
    BlUser32 = 85,
    BlUser33 = 86,
    BlUser34 = 87,
    BlUser35 = 88,
    BlUser36 = 89,
    BlUser37 = 90,
    BlUser38 = 91,
    BlUser39 = 92,
    BlUser40 = 93,
    BlUser41 = 94,
    BlUser42 = 95,
    BlUser43 = 96,
    BlUser44 = 97,
    BlUser45 = 98,
}
impl BoardLayer {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BlUnknown => "BL_UNKNOWN",
            Self::BlUndefined => "BL_UNDEFINED",
            Self::BlUnselected => "BL_UNSELECTED",
            Self::BlFCu => "BL_F_Cu",
            Self::BlIn1Cu => "BL_In1_Cu",
            Self::BlIn2Cu => "BL_In2_Cu",
            Self::BlIn3Cu => "BL_In3_Cu",
            Self::BlIn4Cu => "BL_In4_Cu",
            Self::BlIn5Cu => "BL_In5_Cu",
            Self::BlIn6Cu => "BL_In6_Cu",
            Self::BlIn7Cu => "BL_In7_Cu",
            Self::BlIn8Cu => "BL_In8_Cu",
            Self::BlIn9Cu => "BL_In9_Cu",
            Self::BlIn10Cu => "BL_In10_Cu",
            Self::BlIn11Cu => "BL_In11_Cu",
            Self::BlIn12Cu => "BL_In12_Cu",
            Self::BlIn13Cu => "BL_In13_Cu",
            Self::BlIn14Cu => "BL_In14_Cu",
            Self::BlIn15Cu => "BL_In15_Cu",
            Self::BlIn16Cu => "BL_In16_Cu",
            Self::BlIn17Cu => "BL_In17_Cu",
            Self::BlIn18Cu => "BL_In18_Cu",
            Self::BlIn19Cu => "BL_In19_Cu",
            Self::BlIn20Cu => "BL_In20_Cu",
            Self::BlIn21Cu => "BL_In21_Cu",
            Self::BlIn22Cu => "BL_In22_Cu",
            Self::BlIn23Cu => "BL_In23_Cu",
            Self::BlIn24Cu => "BL_In24_Cu",
            Self::BlIn25Cu => "BL_In25_Cu",
            Self::BlIn26Cu => "BL_In26_Cu",
            Self::BlIn27Cu => "BL_In27_Cu",
            Self::BlIn28Cu => "BL_In28_Cu",
            Self::BlIn29Cu => "BL_In29_Cu",
            Self::BlIn30Cu => "BL_In30_Cu",
            Self::BlBCu => "BL_B_Cu",
            Self::BlBAdhes => "BL_B_Adhes",
            Self::BlFAdhes => "BL_F_Adhes",
            Self::BlBPaste => "BL_B_Paste",
            Self::BlFPaste => "BL_F_Paste",
            Self::BlBSilkS => "BL_B_SilkS",
            Self::BlFSilkS => "BL_F_SilkS",
            Self::BlBMask => "BL_B_Mask",
            Self::BlFMask => "BL_F_Mask",
            Self::BlDwgsUser => "BL_Dwgs_User",
            Self::BlCmtsUser => "BL_Cmts_User",
            Self::BlEco1User => "BL_Eco1_User",
            Self::BlEco2User => "BL_Eco2_User",
            Self::BlEdgeCuts => "BL_Edge_Cuts",
            Self::BlMargin => "BL_Margin",
            Self::BlBCrtYd => "BL_B_CrtYd",
            Self::BlFCrtYd => "BL_F_CrtYd",
            Self::BlBFab => "BL_B_Fab",
            Self::BlFFab => "BL_F_Fab",
            Self::BlUser1 => "BL_User_1",
            Self::BlUser2 => "BL_User_2",
            Self::BlUser3 => "BL_User_3",
            Self::BlUser4 => "BL_User_4",
            Self::BlUser5 => "BL_User_5",
            Self::BlUser6 => "BL_User_6",
            Self::BlUser7 => "BL_User_7",
            Self::BlUser8 => "BL_User_8",
            Self::BlUser9 => "BL_User_9",
            Self::BlRescue => "BL_Rescue",
            Self::BlUser10 => "BL_User_10",
            Self::BlUser11 => "BL_User_11",
            Self::BlUser12 => "BL_User_12",
            Self::BlUser13 => "BL_User_13",
            Self::BlUser14 => "BL_User_14",
            Self::BlUser15 => "BL_User_15",
            Self::BlUser16 => "BL_User_16",
            Self::BlUser17 => "BL_User_17",
            Self::BlUser18 => "BL_User_18",
            Self::BlUser19 => "BL_User_19",
            Self::BlUser20 => "BL_User_20",
            Self::BlUser21 => "BL_User_21",
            Self::BlUser22 => "BL_User_22",
            Self::BlUser23 => "BL_User_23",
            Self::BlUser24 => "BL_User_24",
            Self::BlUser25 => "BL_User_25",
            Self::BlUser26 => "BL_User_26",
            Self::BlUser27 => "BL_User_27",
            Self::BlUser28 => "BL_User_28",
            Self::BlUser29 => "BL_User_29",
            Self::BlUser30 => "BL_User_30",
            Self::BlUser31 => "BL_User_31",
            Self::BlUser32 => "BL_User_32",
            Self::BlUser33 => "BL_User_33",
            Self::BlUser34 => "BL_User_34",
            Self::BlUser35 => "BL_User_35",
            Self::BlUser36 => "BL_User_36",
            Self::BlUser37 => "BL_User_37",
            Self::BlUser38 => "BL_User_38",
            Self::BlUser39 => "BL_User_39",
            Self::BlUser40 => "BL_User_40",
            Self::BlUser41 => "BL_User_41",
            Self::BlUser42 => "BL_User_42",
            Self::BlUser43 => "BL_User_43",
            Self::BlUser44 => "BL_User_44",
            Self::BlUser45 => "BL_User_45",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BL_UNKNOWN" => Some(Self::BlUnknown),
            "BL_UNDEFINED" => Some(Self::BlUndefined),
            "BL_UNSELECTED" => Some(Self::BlUnselected),
            "BL_F_Cu" => Some(Self::BlFCu),
            "BL_In1_Cu" => Some(Self::BlIn1Cu),
            "BL_In2_Cu" => Some(Self::BlIn2Cu),
            "BL_In3_Cu" => Some(Self::BlIn3Cu),
            "BL_In4_Cu" => Some(Self::BlIn4Cu),
            "BL_In5_Cu" => Some(Self::BlIn5Cu),
            "BL_In6_Cu" => Some(Self::BlIn6Cu),
            "BL_In7_Cu" => Some(Self::BlIn7Cu),
            "BL_In8_Cu" => Some(Self::BlIn8Cu),
            "BL_In9_Cu" => Some(Self::BlIn9Cu),
            "BL_In10_Cu" => Some(Self::BlIn10Cu),
            "BL_In11_Cu" => Some(Self::BlIn11Cu),
            "BL_In12_Cu" => Some(Self::BlIn12Cu),
            "BL_In13_Cu" => Some(Self::BlIn13Cu),
            "BL_In14_Cu" => Some(Self::BlIn14Cu),
            "BL_In15_Cu" => Some(Self::BlIn15Cu),
            "BL_In16_Cu" => Some(Self::BlIn16Cu),
            "BL_In17_Cu" => Some(Self::BlIn17Cu),
            "BL_In18_Cu" => Some(Self::BlIn18Cu),
            "BL_In19_Cu" => Some(Self::BlIn19Cu),
            "BL_In20_Cu" => Some(Self::BlIn20Cu),
            "BL_In21_Cu" => Some(Self::BlIn21Cu),
            "BL_In22_Cu" => Some(Self::BlIn22Cu),
            "BL_In23_Cu" => Some(Self::BlIn23Cu),
            "BL_In24_Cu" => Some(Self::BlIn24Cu),
            "BL_In25_Cu" => Some(Self::BlIn25Cu),
            "BL_In26_Cu" => Some(Self::BlIn26Cu),
            "BL_In27_Cu" => Some(Self::BlIn27Cu),
            "BL_In28_Cu" => Some(Self::BlIn28Cu),
            "BL_In29_Cu" => Some(Self::BlIn29Cu),
            "BL_In30_Cu" => Some(Self::BlIn30Cu),
            "BL_B_Cu" => Some(Self::BlBCu),
            "BL_B_Adhes" => Some(Self::BlBAdhes),
            "BL_F_Adhes" => Some(Self::BlFAdhes),
            "BL_B_Paste" => Some(Self::BlBPaste),
            "BL_F_Paste" => Some(Self::BlFPaste),
            "BL_B_SilkS" => Some(Self::BlBSilkS),
            "BL_F_SilkS" => Some(Self::BlFSilkS),
            "BL_B_Mask" => Some(Self::BlBMask),
            "BL_F_Mask" => Some(Self::BlFMask),
            "BL_Dwgs_User" => Some(Self::BlDwgsUser),
            "BL_Cmts_User" => Some(Self::BlCmtsUser),
            "BL_Eco1_User" => Some(Self::BlEco1User),
            "BL_Eco2_User" => Some(Self::BlEco2User),
            "BL_Edge_Cuts" => Some(Self::BlEdgeCuts),
            "BL_Margin" => Some(Self::BlMargin),
            "BL_B_CrtYd" => Some(Self::BlBCrtYd),
            "BL_F_CrtYd" => Some(Self::BlFCrtYd),
            "BL_B_Fab" => Some(Self::BlBFab),
            "BL_F_Fab" => Some(Self::BlFFab),
            "BL_User_1" => Some(Self::BlUser1),
            "BL_User_2" => Some(Self::BlUser2),
            "BL_User_3" => Some(Self::BlUser3),
            "BL_User_4" => Some(Self::BlUser4),
            "BL_User_5" => Some(Self::BlUser5),
            "BL_User_6" => Some(Self::BlUser6),
            "BL_User_7" => Some(Self::BlUser7),
            "BL_User_8" => Some(Self::BlUser8),
            "BL_User_9" => Some(Self::BlUser9),
            "BL_Rescue" => Some(Self::BlRescue),
            "BL_User_10" => Some(Self::BlUser10),
            "BL_User_11" => Some(Self::BlUser11),
            "BL_User_12" => Some(Self::BlUser12),
            "BL_User_13" => Some(Self::BlUser13),
            "BL_User_14" => Some(Self::BlUser14),
            "BL_User_15" => Some(Self::BlUser15),
            "BL_User_16" => Some(Self::BlUser16),
            "BL_User_17" => Some(Self::BlUser17),
            "BL_User_18" => Some(Self::BlUser18),
            "BL_User_19" => Some(Self::BlUser19),
            "BL_User_20" => Some(Self::BlUser20),
            "BL_User_21" => Some(Self::BlUser21),
            "BL_User_22" => Some(Self::BlUser22),
            "BL_User_23" => Some(Self::BlUser23),
            "BL_User_24" => Some(Self::BlUser24),
            "BL_User_25" => Some(Self::BlUser25),
            "BL_User_26" => Some(Self::BlUser26),
            "BL_User_27" => Some(Self::BlUser27),
            "BL_User_28" => Some(Self::BlUser28),
            "BL_User_29" => Some(Self::BlUser29),
            "BL_User_30" => Some(Self::BlUser30),
            "BL_User_31" => Some(Self::BlUser31),
            "BL_User_32" => Some(Self::BlUser32),
            "BL_User_33" => Some(Self::BlUser33),
            "BL_User_34" => Some(Self::BlUser34),
            "BL_User_35" => Some(Self::BlUser35),
            "BL_User_36" => Some(Self::BlUser36),
            "BL_User_37" => Some(Self::BlUser37),
            "BL_User_38" => Some(Self::BlUser38),
            "BL_User_39" => Some(Self::BlUser39),
            "BL_User_40" => Some(Self::BlUser40),
            "BL_User_41" => Some(Self::BlUser41),
            "BL_User_42" => Some(Self::BlUser42),
            "BL_User_43" => Some(Self::BlUser43),
            "BL_User_44" => Some(Self::BlUser44),
            "BL_User_45" => Some(Self::BlUser45),
            _ => None,
        }
    }
}
/// What copper layer shape mode the padstack uses
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadStackType {
    PstUnknown = 0,
    /// The same shape is used on all copper layers
    PstNormal = 1,
    /// The padstack uses up to three different shapes (F_Cu, inner layers, B_Cu)
    PstFrontInnerBack = 2,
    /// The padstack's shape may differ on arbitrary copper layers
    PstCustom = 3,
}
impl PadStackType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PstUnknown => "PST_UNKNOWN",
            Self::PstNormal => "PST_NORMAL",
            Self::PstFrontInnerBack => "PST_FRONT_INNER_BACK",
            Self::PstCustom => "PST_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PST_UNKNOWN" => Some(Self::PstUnknown),
            "PST_NORMAL" => Some(Self::PstNormal),
            "PST_FRONT_INNER_BACK" => Some(Self::PstFrontInnerBack),
            "PST_CUSTOM" => Some(Self::PstCustom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnconnectedLayerRemoval {
    UlrUnknown = 0,
    /// Keep annular rings on all layers
    UlrKeep = 1,
    /// Remove annular rings on unconnected layers, including start and end layers.
    UlrRemove = 2,
    /// Remove annular rings on unconnected layers, but preserve start and end layers even if unconnected.
    UlrRemoveExceptStartAndEnd = 3,
    /// Keep annular rings only on the start and end layers regardless of connections.
    /// Since: 10.0.0
    UlrStartEndOnly = 4,
}
impl UnconnectedLayerRemoval {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UlrUnknown => "ULR_UNKNOWN",
            Self::UlrKeep => "ULR_KEEP",
            Self::UlrRemove => "ULR_REMOVE",
            Self::UlrRemoveExceptStartAndEnd => "ULR_REMOVE_EXCEPT_START_AND_END",
            Self::UlrStartEndOnly => "ULR_START_END_ONLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ULR_UNKNOWN" => Some(Self::UlrUnknown),
            "ULR_KEEP" => Some(Self::UlrKeep),
            "ULR_REMOVE" => Some(Self::UlrRemove),
            "ULR_REMOVE_EXCEPT_START_AND_END" => Some(Self::UlrRemoveExceptStartAndEnd),
            "ULR_START_END_ONLY" => Some(Self::UlrStartEndOnly),
            _ => None,
        }
    }
}
/// The shape of a pad on a given layer
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadStackShape {
    PssUnknown = 0,
    PssCircle = 1,
    PssRectangle = 2,
    PssOval = 3,
    PssTrapezoid = 4,
    PssRoundrect = 5,
    PssChamferedrect = 6,
    PssCustom = 7,
}
impl PadStackShape {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PssUnknown => "PSS_UNKNOWN",
            Self::PssCircle => "PSS_CIRCLE",
            Self::PssRectangle => "PSS_RECTANGLE",
            Self::PssOval => "PSS_OVAL",
            Self::PssTrapezoid => "PSS_TRAPEZOID",
            Self::PssRoundrect => "PSS_ROUNDRECT",
            Self::PssChamferedrect => "PSS_CHAMFEREDRECT",
            Self::PssCustom => "PSS_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PSS_UNKNOWN" => Some(Self::PssUnknown),
            "PSS_CIRCLE" => Some(Self::PssCircle),
            "PSS_RECTANGLE" => Some(Self::PssRectangle),
            "PSS_OVAL" => Some(Self::PssOval),
            "PSS_TRAPEZOID" => Some(Self::PssTrapezoid),
            "PSS_ROUNDRECT" => Some(Self::PssRoundrect),
            "PSS_CHAMFEREDRECT" => Some(Self::PssChamferedrect),
            "PSS_CUSTOM" => Some(Self::PssCustom),
            _ => None,
        }
    }
}
/// enum class ZONE_CONNECTION
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneConnectionStyle {
    ZcsUnknown = 0,
    ZcsInherited = 1,
    ZcsNone = 2,
    ZcsThermal = 3,
    ZcsFull = 4,
    /// Thermal reliefs for plated through holes, solid for SMD pads
    ZcsPthThermal = 5,
}
impl ZoneConnectionStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZcsUnknown => "ZCS_UNKNOWN",
            Self::ZcsInherited => "ZCS_INHERITED",
            Self::ZcsNone => "ZCS_NONE",
            Self::ZcsThermal => "ZCS_THERMAL",
            Self::ZcsFull => "ZCS_FULL",
            Self::ZcsPthThermal => "ZCS_PTH_THERMAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZCS_UNKNOWN" => Some(Self::ZcsUnknown),
            "ZCS_INHERITED" => Some(Self::ZcsInherited),
            "ZCS_NONE" => Some(Self::ZcsNone),
            "ZCS_THERMAL" => Some(Self::ZcsThermal),
            "ZCS_FULL" => Some(Self::ZcsFull),
            "ZCS_PTH_THERMAL" => Some(Self::ZcsPthThermal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolderMaskMode {
    SmmUnknown = 0,
    SmmMasked = 1,
    SmmUnmasked = 2,
    SmmFromDesignRules = 3,
}
impl SolderMaskMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SmmUnknown => "SMM_UNKNOWN",
            Self::SmmMasked => "SMM_MASKED",
            Self::SmmUnmasked => "SMM_UNMASKED",
            Self::SmmFromDesignRules => "SMM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SMM_UNKNOWN" => Some(Self::SmmUnknown),
            "SMM_MASKED" => Some(Self::SmmMasked),
            "SMM_UNMASKED" => Some(Self::SmmUnmasked),
            "SMM_FROM_DESIGN_RULES" => Some(Self::SmmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaCoveringMode {
    VcmUnknown = 0,
    VcmCovered = 1,
    VcmUncovered = 2,
    VcmFromDesignRules = 3,
}
impl ViaCoveringMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VcmUnknown => "VCM_UNKNOWN",
            Self::VcmCovered => "VCM_COVERED",
            Self::VcmUncovered => "VCM_UNCOVERED",
            Self::VcmFromDesignRules => "VCM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VCM_UNKNOWN" => Some(Self::VcmUnknown),
            "VCM_COVERED" => Some(Self::VcmCovered),
            "VCM_UNCOVERED" => Some(Self::VcmUncovered),
            "VCM_FROM_DESIGN_RULES" => Some(Self::VcmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaPluggingMode {
    VpmUnknown = 0,
    VpmPlugged = 1,
    VpmUnplugged = 2,
    VpmFromDesignRules = 3,
}
impl ViaPluggingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VpmUnknown => "VPM_UNKNOWN",
            Self::VpmPlugged => "VPM_PLUGGED",
            Self::VpmUnplugged => "VPM_UNPLUGGED",
            Self::VpmFromDesignRules => "VPM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VPM_UNKNOWN" => Some(Self::VpmUnknown),
            "VPM_PLUGGED" => Some(Self::VpmPlugged),
            "VPM_UNPLUGGED" => Some(Self::VpmUnplugged),
            "VPM_FROM_DESIGN_RULES" => Some(Self::VpmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolderPasteMode {
    SpmUnknown = 0,
    SpmPaste = 1,
    SpmNoPaste = 2,
    SpmFromDesignRules = 3,
}
impl SolderPasteMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SpmUnknown => "SPM_UNKNOWN",
            Self::SpmPaste => "SPM_PASTE",
            Self::SpmNoPaste => "SPM_NO_PASTE",
            Self::SpmFromDesignRules => "SPM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPM_UNKNOWN" => Some(Self::SpmUnknown),
            "SPM_PASTE" => Some(Self::SpmPaste),
            "SPM_NO_PASTE" => Some(Self::SpmNoPaste),
            "SPM_FROM_DESIGN_RULES" => Some(Self::SpmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DrillShape {
    DsUnknown = 0,
    DsCircle = 1,
    DsOblong = 2,
    DsUndefined = 3,
}
impl DrillShape {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DsUnknown => "DS_UNKNOWN",
            Self::DsCircle => "DS_CIRCLE",
            Self::DsOblong => "DS_OBLONG",
            Self::DsUndefined => "DS_UNDEFINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DS_UNKNOWN" => Some(Self::DsUnknown),
            "DS_CIRCLE" => Some(Self::DsCircle),
            "DS_OBLONG" => Some(Self::DsOblong),
            "DS_UNDEFINED" => Some(Self::DsUndefined),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaDrillCappingMode {
    VdcmUnknown = 0,
    VdcmCapped = 1,
    VdcmUncapped = 2,
    VdcmFromDesignRules = 3,
}
impl ViaDrillCappingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VdcmUnknown => "VDCM_UNKNOWN",
            Self::VdcmCapped => "VDCM_CAPPED",
            Self::VdcmUncapped => "VDCM_UNCAPPED",
            Self::VdcmFromDesignRules => "VDCM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VDCM_UNKNOWN" => Some(Self::VdcmUnknown),
            "VDCM_CAPPED" => Some(Self::VdcmCapped),
            "VDCM_UNCAPPED" => Some(Self::VdcmUncapped),
            "VDCM_FROM_DESIGN_RULES" => Some(Self::VdcmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaDrillFillingMode {
    VdfmUnknown = 0,
    VdfmFilled = 1,
    VdfmUnfilled = 2,
    VdfmFromDesignRules = 3,
}
impl ViaDrillFillingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VdfmUnknown => "VDFM_UNKNOWN",
            Self::VdfmFilled => "VDFM_FILLED",
            Self::VdfmUnfilled => "VDFM_UNFILLED",
            Self::VdfmFromDesignRules => "VDFM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VDFM_UNKNOWN" => Some(Self::VdfmUnknown),
            "VDFM_FILLED" => Some(Self::VdfmFilled),
            "VDFM_UNFILLED" => Some(Self::VdfmUnfilled),
            "VDFM_FROM_DESIGN_RULES" => Some(Self::VdfmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaDrillPostMachiningMode {
    VdpmUnknown = 0,
    VdpmNotPostMachined = 1,
    VdpmCounterbore = 2,
    VdpmCountersink = 3,
}
impl ViaDrillPostMachiningMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VdpmUnknown => "VDPM_UNKNOWN",
            Self::VdpmNotPostMachined => "VDPM_NOT_POST_MACHINED",
            Self::VdpmCounterbore => "VDPM_COUNTERBORE",
            Self::VdpmCountersink => "VDPM_COUNTERSINK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VDPM_UNKNOWN" => Some(Self::VdpmUnknown),
            "VDPM_NOT_POST_MACHINED" => Some(Self::VdpmNotPostMachined),
            "VDPM_COUNTERBORE" => Some(Self::VdpmCounterbore),
            "VDPM_COUNTERSINK" => Some(Self::VdpmCountersink),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaType {
    VtUnknown = 0,
    /// Through vias always start on F_Cu and end on B_Cu
    VtThrough = 1,
    /// Blind/buried vias can have arbitrary start and end layers
    VtBlindBuried = 2,
    /// Microvias, blind/buried vias, can have arbitrary start and end layers, but also have different
    /// size defaults and design rules
    VtMicro = 3,
    /// Blind vias start on an outer layer and end in the middle
    ///
    /// Since V10
    VtBlind = 4,
    /// Buried vias start and end on inner layers
    ///
    /// Since V10
    VtBuried = 5,
}
impl ViaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VtUnknown => "VT_UNKNOWN",
            Self::VtThrough => "VT_THROUGH",
            Self::VtBlindBuried => "VT_BLIND_BURIED",
            Self::VtMicro => "VT_MICRO",
            Self::VtBlind => "VT_BLIND",
            Self::VtBuried => "VT_BURIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VT_UNKNOWN" => Some(Self::VtUnknown),
            "VT_THROUGH" => Some(Self::VtThrough),
            "VT_BLIND_BURIED" => Some(Self::VtBlindBuried),
            "VT_MICRO" => Some(Self::VtMicro),
            "VT_BLIND" => Some(Self::VtBlind),
            "VT_BURIED" => Some(Self::VtBuried),
            _ => None,
        }
    }
}
/// NOTE: There has been some discussion about what to do with pad attributes and properties.
/// This may be considered somewhat unstable until we decide what to do with the KiCad side.
/// It is not clear what the set of mutually-exclusive pad types will be at the end of the day,
/// versus what will be non-exclusive attributes/properties.
/// For now, this maps to PAD_ATTRIB in KiCad.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadType {
    PtUnknown = 0,
    PtPth = 1,
    PtSmd = 2,
    PtEdgeConnector = 3,
    PtNpth = 4,
}
impl PadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PtUnknown => "PT_UNKNOWN",
            Self::PtPth => "PT_PTH",
            Self::PtSmd => "PT_SMD",
            Self::PtEdgeConnector => "PT_EDGE_CONNECTOR",
            Self::PtNpth => "PT_NPTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PT_UNKNOWN" => Some(Self::PtUnknown),
            "PT_PTH" => Some(Self::PtPth),
            "PT_SMD" => Some(Self::PtSmd),
            "PT_EDGE_CONNECTOR" => Some(Self::PtEdgeConnector),
            "PT_NPTH" => Some(Self::PtNpth),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomPadShapeZoneFillStrategy {
    CpszUnknown = 0,
    CpszOutline = 1,
    CpszConvexhull = 2,
}
impl CustomPadShapeZoneFillStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CpszUnknown => "CPSZ_UNKNOWN",
            Self::CpszOutline => "CPSZ_OUTLINE",
            Self::CpszConvexhull => "CPSZ_CONVEXHULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CPSZ_UNKNOWN" => Some(Self::CpszUnknown),
            "CPSZ_OUTLINE" => Some(Self::CpszOutline),
            "CPSZ_CONVEXHULL" => Some(Self::CpszConvexhull),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneType {
    ZtUnknown = 0,
    ZtCopper = 1,
    ZtGraphical = 2,
    ZtRuleArea = 3,
    ZtTeardrop = 4,
}
impl ZoneType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZtUnknown => "ZT_UNKNOWN",
            Self::ZtCopper => "ZT_COPPER",
            Self::ZtGraphical => "ZT_GRAPHICAL",
            Self::ZtRuleArea => "ZT_RULE_AREA",
            Self::ZtTeardrop => "ZT_TEARDROP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZT_UNKNOWN" => Some(Self::ZtUnknown),
            "ZT_COPPER" => Some(Self::ZtCopper),
            "ZT_GRAPHICAL" => Some(Self::ZtGraphical),
            "ZT_RULE_AREA" => Some(Self::ZtRuleArea),
            "ZT_TEARDROP" => Some(Self::ZtTeardrop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TeardropType {
    TdtUnknown = 0,
    TdtNone = 1,
    TdtUnspecified = 2,
    TdtViaPad = 3,
    TdtTrackEnd = 4,
}
impl TeardropType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TdtUnknown => "TDT_UNKNOWN",
            Self::TdtNone => "TDT_NONE",
            Self::TdtUnspecified => "TDT_UNSPECIFIED",
            Self::TdtViaPad => "TDT_VIA_PAD",
            Self::TdtTrackEnd => "TDT_TRACK_END",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TDT_UNKNOWN" => Some(Self::TdtUnknown),
            "TDT_NONE" => Some(Self::TdtNone),
            "TDT_UNSPECIFIED" => Some(Self::TdtUnspecified),
            "TDT_VIA_PAD" => Some(Self::TdtViaPad),
            "TDT_TRACK_END" => Some(Self::TdtTrackEnd),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IslandRemovalMode {
    IrmUnknown = 0,
    IrmAlways = 1,
    IrmNever = 2,
    IrmArea = 3,
}
impl IslandRemovalMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::IrmUnknown => "IRM_UNKNOWN",
            Self::IrmAlways => "IRM_ALWAYS",
            Self::IrmNever => "IRM_NEVER",
            Self::IrmArea => "IRM_AREA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IRM_UNKNOWN" => Some(Self::IrmUnknown),
            "IRM_ALWAYS" => Some(Self::IrmAlways),
            "IRM_NEVER" => Some(Self::IrmNever),
            "IRM_AREA" => Some(Self::IrmArea),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneFillMode {
    ZfmUnknown = 0,
    ZfmSolid = 1,
    ZfmHatched = 2,
}
impl ZoneFillMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZfmUnknown => "ZFM_UNKNOWN",
            Self::ZfmSolid => "ZFM_SOLID",
            Self::ZfmHatched => "ZFM_HATCHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZFM_UNKNOWN" => Some(Self::ZfmUnknown),
            "ZFM_SOLID" => Some(Self::ZfmSolid),
            "ZFM_HATCHED" => Some(Self::ZfmHatched),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneHatchSmoothing {
    ZhsUnknown = 0,
    ZhsNone = 1,
    ZhsFillet = 2,
    ZhsArcLowDef = 3,
    ZhsArcHighDef = 4,
}
impl ZoneHatchSmoothing {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZhsUnknown => "ZHS_UNKNOWN",
            Self::ZhsNone => "ZHS_NONE",
            Self::ZhsFillet => "ZHS_FILLET",
            Self::ZhsArcLowDef => "ZHS_ARC_LOW_DEF",
            Self::ZhsArcHighDef => "ZHS_ARC_HIGH_DEF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZHS_UNKNOWN" => Some(Self::ZhsUnknown),
            "ZHS_NONE" => Some(Self::ZhsNone),
            "ZHS_FILLET" => Some(Self::ZhsFillet),
            "ZHS_ARC_LOW_DEF" => Some(Self::ZhsArcLowDef),
            "ZHS_ARC_HIGH_DEF" => Some(Self::ZhsArcHighDef),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneHatchFillBorderMode {
    ZhfbmUnknown = 0,
    ZhfbmUseMinZoneThickness = 1,
    ZhfbmUseHatchThickness = 2,
}
impl ZoneHatchFillBorderMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZhfbmUnknown => "ZHFBM_UNKNOWN",
            Self::ZhfbmUseMinZoneThickness => "ZHFBM_USE_MIN_ZONE_THICKNESS",
            Self::ZhfbmUseHatchThickness => "ZHFBM_USE_HATCH_THICKNESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZHFBM_UNKNOWN" => Some(Self::ZhfbmUnknown),
            "ZHFBM_USE_MIN_ZONE_THICKNESS" => Some(Self::ZhfbmUseMinZoneThickness),
            "ZHFBM_USE_HATCH_THICKNESS" => Some(Self::ZhfbmUseHatchThickness),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlacementRuleSourceType {
    PrstUnknown = 0,
    PrstSheetName = 1,
    PrstComponentClass = 2,
    PrstGroup = 3,
    PrstDesignBlock = 4,
}
impl PlacementRuleSourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PrstUnknown => "PRST_UNKNOWN",
            Self::PrstSheetName => "PRST_SHEET_NAME",
            Self::PrstComponentClass => "PRST_COMPONENT_CLASS",
            Self::PrstGroup => "PRST_GROUP",
            Self::PrstDesignBlock => "PRST_DESIGN_BLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRST_UNKNOWN" => Some(Self::PrstUnknown),
            "PRST_SHEET_NAME" => Some(Self::PrstSheetName),
            "PRST_COMPONENT_CLASS" => Some(Self::PrstComponentClass),
            "PRST_GROUP" => Some(Self::PrstGroup),
            "PRST_DESIGN_BLOCK" => Some(Self::PrstDesignBlock),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneBorderStyle {
    ZbsUnknown = 0,
    ZbsSolid = 1,
    ZbsDiagonalFull = 2,
    ZbsDiagonalEdge = 3,
    ZbsInvisible = 4,
}
impl ZoneBorderStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ZbsUnknown => "ZBS_UNKNOWN",
            Self::ZbsSolid => "ZBS_SOLID",
            Self::ZbsDiagonalFull => "ZBS_DIAGONAL_FULL",
            Self::ZbsDiagonalEdge => "ZBS_DIAGONAL_EDGE",
            Self::ZbsInvisible => "ZBS_INVISIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZBS_UNKNOWN" => Some(Self::ZbsUnknown),
            "ZBS_SOLID" => Some(Self::ZbsSolid),
            "ZBS_DIAGONAL_FULL" => Some(Self::ZbsDiagonalFull),
            "ZBS_DIAGONAL_EDGE" => Some(Self::ZbsDiagonalEdge),
            "ZBS_INVISIBLE" => Some(Self::ZbsInvisible),
            _ => None,
        }
    }
}
/// The style of the optional frame applied to dimension text
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionTextBorderStyle {
    DtbsUnknown = 0,
    DtbsNone = 1,
    DtbsRectangle = 2,
    DtbsCircle = 3,
    DtbsRoundrect = 4,
}
impl DimensionTextBorderStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DtbsUnknown => "DTBS_UNKNOWN",
            Self::DtbsNone => "DTBS_NONE",
            Self::DtbsRectangle => "DTBS_RECTANGLE",
            Self::DtbsCircle => "DTBS_CIRCLE",
            Self::DtbsRoundrect => "DTBS_ROUNDRECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DTBS_UNKNOWN" => Some(Self::DtbsUnknown),
            "DTBS_NONE" => Some(Self::DtbsNone),
            "DTBS_RECTANGLE" => Some(Self::DtbsRectangle),
            "DTBS_CIRCLE" => Some(Self::DtbsCircle),
            "DTBS_ROUNDRECT" => Some(Self::DtbsRoundrect),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionUnitFormat {
    DufUnknown = 0,
    DufNoSuffix = 1,
    DufBareSuffix = 2,
    DufParenSuffix = 3,
}
impl DimensionUnitFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DufUnknown => "DUF_UNKNOWN",
            Self::DufNoSuffix => "DUF_NO_SUFFIX",
            Self::DufBareSuffix => "DUF_BARE_SUFFIX",
            Self::DufParenSuffix => "DUF_PAREN_SUFFIX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUF_UNKNOWN" => Some(Self::DufUnknown),
            "DUF_NO_SUFFIX" => Some(Self::DufNoSuffix),
            "DUF_BARE_SUFFIX" => Some(Self::DufBareSuffix),
            "DUF_PAREN_SUFFIX" => Some(Self::DufParenSuffix),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionArrowDirection {
    DadUnknown = 0,
    DadInward = 1,
    DadOutward = 2,
}
impl DimensionArrowDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DadUnknown => "DAD_UNKNOWN",
            Self::DadInward => "DAD_INWARD",
            Self::DadOutward => "DAD_OUTWARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DAD_UNKNOWN" => Some(Self::DadUnknown),
            "DAD_INWARD" => Some(Self::DadInward),
            "DAD_OUTWARD" => Some(Self::DadOutward),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionPrecision {
    DpUnknown = 0,
    /// No digits after decimal point
    DpFixed0 = 1,
    /// 1 digit after decimal point
    DpFixed1 = 2,
    /// 2 digits after decimal point
    DpFixed2 = 3,
    /// 3 digits after decimal point
    DpFixed3 = 4,
    /// 4 digits after decimal point
    DpFixed4 = 5,
    /// 5 digits after decimal point
    DpFixed5 = 6,
    /// Precision depends on unit selection; 2 digits for inches, 0 for mils, 1 for mm
    DpScaledIn2 = 7,
    /// Precision depends on unit selection; 3 digits for inches, 0 for mils, 2 for mm
    DpScaledIn3 = 8,
    /// Precision depends on unit selection; 4 digits for inches, 1 for mils, 3 for mm
    DpScaledIn4 = 9,
    /// Precision depends on unit selection; 5 digits for inches, 2 for mils, 4 for mm
    DpScaledIn5 = 10,
}
impl DimensionPrecision {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DpUnknown => "DP_UNKNOWN",
            Self::DpFixed0 => "DP_FIXED_0",
            Self::DpFixed1 => "DP_FIXED_1",
            Self::DpFixed2 => "DP_FIXED_2",
            Self::DpFixed3 => "DP_FIXED_3",
            Self::DpFixed4 => "DP_FIXED_4",
            Self::DpFixed5 => "DP_FIXED_5",
            Self::DpScaledIn2 => "DP_SCALED_IN_2",
            Self::DpScaledIn3 => "DP_SCALED_IN_3",
            Self::DpScaledIn4 => "DP_SCALED_IN_4",
            Self::DpScaledIn5 => "DP_SCALED_IN_5",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DP_UNKNOWN" => Some(Self::DpUnknown),
            "DP_FIXED_0" => Some(Self::DpFixed0),
            "DP_FIXED_1" => Some(Self::DpFixed1),
            "DP_FIXED_2" => Some(Self::DpFixed2),
            "DP_FIXED_3" => Some(Self::DpFixed3),
            "DP_FIXED_4" => Some(Self::DpFixed4),
            "DP_FIXED_5" => Some(Self::DpFixed5),
            "DP_SCALED_IN_2" => Some(Self::DpScaledIn2),
            "DP_SCALED_IN_3" => Some(Self::DpScaledIn3),
            "DP_SCALED_IN_4" => Some(Self::DpScaledIn4),
            "DP_SCALED_IN_5" => Some(Self::DpScaledIn5),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionTextPosition {
    DtpUnknown = 0,
    DtpOutside = 1,
    DtpInline = 2,
    DtpManual = 3,
}
impl DimensionTextPosition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DtpUnknown => "DTP_UNKNOWN",
            Self::DtpOutside => "DTP_OUTSIDE",
            Self::DtpInline => "DTP_INLINE",
            Self::DtpManual => "DTP_MANUAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DTP_UNKNOWN" => Some(Self::DtpUnknown),
            "DTP_OUTSIDE" => Some(Self::DtpOutside),
            "DTP_INLINE" => Some(Self::DtpInline),
            "DTP_MANUAL" => Some(Self::DtpManual),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionUnit {
    DuUnknown = 0,
    DuInches = 1,
    DuMils = 2,
    DuMillimeters = 3,
    DuAutomatic = 4,
}
impl DimensionUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DuUnknown => "DU_UNKNOWN",
            Self::DuInches => "DU_INCHES",
            Self::DuMils => "DU_MILS",
            Self::DuMillimeters => "DU_MILLIMETERS",
            Self::DuAutomatic => "DU_AUTOMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DU_UNKNOWN" => Some(Self::DuUnknown),
            "DU_INCHES" => Some(Self::DuInches),
            "DU_MILS" => Some(Self::DuMils),
            "DU_MILLIMETERS" => Some(Self::DuMillimeters),
            "DU_AUTOMATIC" => Some(Self::DuAutomatic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FootprintMountingStyle {
    FmsUnknown = 0,
    FmsThroughHole = 1,
    FmsSmd = 2,
    FmsUnspecified = 3,
}
impl FootprintMountingStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FmsUnknown => "FMS_UNKNOWN",
            Self::FmsThroughHole => "FMS_THROUGH_HOLE",
            Self::FmsSmd => "FMS_SMD",
            Self::FmsUnspecified => "FMS_UNSPECIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FMS_UNKNOWN" => Some(Self::FmsUnknown),
            "FMS_THROUGH_HOLE" => Some(Self::FmsThroughHole),
            "FMS_SMD" => Some(Self::FmsSmd),
            "FMS_UNSPECIFIED" => Some(Self::FmsUnspecified),
            _ => None,
        }
    }
}
