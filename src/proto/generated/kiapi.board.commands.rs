// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardStackup {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardStackupResponse {
    #[prost(message, optional, tag = "1")]
    pub stackup: ::core::option::Option<super::BoardStackup>,
}
/// Changes the stackup for the given board according to the contents of the message (**not yet implemented**)
/// WARNING: any existing content on layers that are removed by this call is deleted.  This operation cannot be undone.
/// Returns BoardStackupResponse with the updated stackup, in normalized form
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBoardStackup {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(message, optional, tag = "2")]
    pub stackup: ::core::option::Option<super::BoardStackup>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardEnabledLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoardEnabledLayersResponse {
    /// The number of copper layers enabled in this board.
    #[prost(uint32, tag = "1")]
    pub copper_layer_count: u32,
    /// A list of all layers enabled in this board, including copper layers and ones which cannot be disabled.
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
/// Changes which layers are enabled in the board stackup
/// WARNING: any existing content on layers that are removed by this call is deleted.  This operation cannot be undone.
/// Returns BoardEnabledLayersResponse with the updated layer set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBoardEnabledLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// The number of copper layers to enable in the board.  Currently, this must be an even number >= 2.
    #[prost(uint32, tag = "2")]
    pub copper_layer_count: u32,
    /// The non-copper layers to enable.  Note that any copper layers in this list are ignored; copper layers are enabled
    /// by setting copper_layer_count.  Note that the F/B.Courtyard, Edge.Cuts, and Margin layers cannot be disabled and
    /// will be present in the board even if they are omitted from this list.
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "3")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGraphicsDefaults {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicsDefaultsResponse {
    #[prost(message, optional, tag = "1")]
    pub defaults: ::core::option::Option<super::GraphicsDefaults>,
}
/// Returns a Vector2 with the specified origin point
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardOrigin {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "BoardOriginType", tag = "2")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBoardOrigin {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "BoardOriginType", tag = "2")]
    pub r#type: i32,
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<super::super::common::types::Vector2>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNets {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// If provided, will only return nets that belong to the given netclass.
    /// If more than one netclass_filter is given, nets belonging to any of the given classes will
    /// be returned.
    #[prost(string, repeated, tag = "2")]
    pub netclass_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub nets: ::prost::alloc::vec::Vec<super::types::Net>,
}
/// Retrieve all the copper items belonging to a certain net or set of nets
/// returns kiapi.common.commands.GetItemsResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsByNet {
    /// Specifies which document to query, which fields to return, etc.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<super::super::common::types::ItemHeader>,
    /// List of one or more types of items to retreive
    #[prost(
        enumeration = "super::super::common::types::KiCadObjectType",
        repeated,
        tag = "2"
    )]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// A list of net codes to filter items by
    #[prost(message, repeated, tag = "3")]
    pub net_codes: ::prost::alloc::vec::Vec<super::types::NetCode>,
}
/// Retrieve all the copper items belonging to a certain net class or set of net classes
/// returns kiapi.common.commands.GetItemsResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsByNetClass {
    /// Specifies which document to query, which fields to return, etc.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<super::super::common::types::ItemHeader>,
    /// List of one or more types of items to retreive
    #[prost(
        enumeration = "super::super::common::types::KiCadObjectType",
        repeated,
        tag = "2"
    )]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// A list of net class names to filter items by
    #[prost(string, repeated, tag = "3")]
    pub net_classes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A net may be part of multiple classes that have a priority ordering, which will result in a
/// composite "effective" netclass containing the merged/overridden properties of all the constituent
/// netclasses it contains.  This message retrieves this effective netclass for a net or list of
/// nets.
/// Returns NetClassForNetsResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetClassForNets {
    #[prost(message, repeated, tag = "1")]
    pub net: ::prost::alloc::vec::Vec<super::types::Net>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetClassForNetsResponse {
    /// Map of net name to netclass info
    #[prost(map = "string, message", tag = "1")]
    pub classes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::project::NetClass,
    >,
}
/// Refills some or all zones on the board.
/// This is a blocking operation; it will return Empty immediately, but KiCad will return
/// ApiStatusCode.AS_BUSY to all future API requests until the zone fill has completed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefillZones {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// A list of zones to refill.  If empty, all zones are refilled.
    #[prost(message, repeated, tag = "2")]
    pub zones: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
/// Computes the polygon representation of a pad, merging any custom shapes together.
/// This representation will approximate curves as a series of segments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPadShapeAsPolygon {
    /// The board to process
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// A list of one or more pads to process
    #[prost(message, repeated, tag = "2")]
    pub pads: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
    /// The layer to process
    #[prost(enumeration = "super::types::BoardLayer", tag = "3")]
    pub layer: i32,
}
/// Returned from GetPadShapeAsPolygon.  The pads and polygons repeated fields will have the same length
/// and can be treated as a list of tuples.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadShapeAsPolygonResponse {
    /// The pads that were processed
    #[prost(message, repeated, tag = "1")]
    pub pads: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
    /// The polygon representation of each pad
    #[prost(message, repeated, tag = "2")]
    pub polygons: ::prost::alloc::vec::Vec<
        super::super::common::types::PolygonWithHoles,
    >,
}
/// Tests if the given set of items with padstacks (pads or vias) has content on the given set of layers.
/// This is a dynamic call rather than a property of the padstack because pads and vias can be set to only include
/// shapes on connected copper layers, and whether or not the pad is connected can't be determined in isolation.
/// To optimize API call performance, multiple items and multiple layers to test may be passed in with this
/// command message.  The return will include the results for each valid item on each valid layer.
/// Note that not all layers make sense for a given item (for example, testing against BL_UNDEFINED never makes
/// sense).  In general, the internal KiCad APIs will not return an error when testing non-sensical layers for a given
/// item, and instead will return a default of "true" for any such layers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckPadstackPresenceOnLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "3")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PadstackPresenceEntry {
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::types::BoardLayer", tag = "2")]
    pub layer: i32,
    #[prost(enumeration = "PadstackPresence", tag = "3")]
    pub presence: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadstackPresenceResponse {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<PadstackPresenceEntry>,
}
/// Returns InjectDrcErrorResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InjectDrcError {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "DrcSeverity", tag = "2")]
    pub severity: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InjectDrcErrorResponse {
    #[prost(message, optional, tag = "1")]
    pub marker: ::core::option::Option<super::super::common::types::Kiid>,
}
/// returns BoardLayers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisibleLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoardLayerResponse {
    #[prost(enumeration = "super::types::BoardLayer", tag = "1")]
    pub layer: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoardLayers {
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "1")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVisibleLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
/// returns BoardLayerResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveLayer {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActiveLayer {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "super::types::BoardLayer", tag = "2")]
    pub layer: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoardEditorAppearanceSettings {
    #[prost(enumeration = "InactiveLayerDisplayMode", tag = "1")]
    pub inactive_layer_display: i32,
    #[prost(enumeration = "NetColorDisplayMode", tag = "2")]
    pub net_color_display: i32,
    #[prost(enumeration = "BoardFlipMode", tag = "3")]
    pub board_flip: i32,
    #[prost(enumeration = "RatsnestDisplayMode", tag = "4")]
    pub ratsnest_display: i32,
}
/// Returns BoardEditorAppearanceSettings
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBoardEditorAppearanceSettings {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetBoardEditorAppearanceSettings {
    #[prost(message, optional, tag = "1")]
    pub settings: ::core::option::Option<BoardEditorAppearanceSettings>,
}
/// Selects and begins an interactive move of the given item(s).
/// NOTE: Takes ownership of the active commit, if one exists:
///        the move tool will push the commit when the user confirms the move,
///        or roll back the commit if the user cancels the move.  Keep this in
///        mind if using this command in combination with commands that create
///        or modify items using an explicit commit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractiveMoveItems {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoardOriginType {
    BotUnknown = 0,
    BotGrid = 1,
    BotDrill = 2,
}
impl BoardOriginType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BotUnknown => "BOT_UNKNOWN",
            Self::BotGrid => "BOT_GRID",
            Self::BotDrill => "BOT_DRILL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOT_UNKNOWN" => Some(Self::BotUnknown),
            "BOT_GRID" => Some(Self::BotGrid),
            "BOT_DRILL" => Some(Self::BotDrill),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadstackPresence {
    PspUnknown = 0,
    /// The padstack has a shape on a given layer (is flashed)
    PspPresent = 1,
    /// The padstack has no shape on a given layer (is not flashed)
    PspNotPresent = 2,
}
impl PadstackPresence {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PspUnknown => "PSP_UNKNOWN",
            Self::PspPresent => "PSP_PRESENT",
            Self::PspNotPresent => "PSP_NOT_PRESENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PSP_UNKNOWN" => Some(Self::PspUnknown),
            "PSP_PRESENT" => Some(Self::PspPresent),
            "PSP_NOT_PRESENT" => Some(Self::PspNotPresent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DrcSeverity {
    DrsUnknown = 0,
    DrsWarning = 1,
    DrsError = 2,
    DrsExclusion = 3,
    DrsIgnore = 4,
    DrsInfo = 5,
    DrsAction = 6,
    DrsDebug = 7,
    DrsUndefined = 8,
}
impl DrcSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DrsUnknown => "DRS_UNKNOWN",
            Self::DrsWarning => "DRS_WARNING",
            Self::DrsError => "DRS_ERROR",
            Self::DrsExclusion => "DRS_EXCLUSION",
            Self::DrsIgnore => "DRS_IGNORE",
            Self::DrsInfo => "DRS_INFO",
            Self::DrsAction => "DRS_ACTION",
            Self::DrsDebug => "DRS_DEBUG",
            Self::DrsUndefined => "DRS_UNDEFINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DRS_UNKNOWN" => Some(Self::DrsUnknown),
            "DRS_WARNING" => Some(Self::DrsWarning),
            "DRS_ERROR" => Some(Self::DrsError),
            "DRS_EXCLUSION" => Some(Self::DrsExclusion),
            "DRS_IGNORE" => Some(Self::DrsIgnore),
            "DRS_INFO" => Some(Self::DrsInfo),
            "DRS_ACTION" => Some(Self::DrsAction),
            "DRS_DEBUG" => Some(Self::DrsDebug),
            "DRS_UNDEFINED" => Some(Self::DrsUndefined),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InactiveLayerDisplayMode {
    IldmUnknown = 0,
    /// Inactive layers are shown
    IldmNormal = 1,
    /// Inactive layers are shown with dimmed colors
    IldmDimmed = 2,
    /// Inactive layers are hidden
    IldmHidden = 3,
}
impl InactiveLayerDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::IldmUnknown => "ILDM_UNKNOWN",
            Self::IldmNormal => "ILDM_NORMAL",
            Self::IldmDimmed => "ILDM_DIMMED",
            Self::IldmHidden => "ILDM_HIDDEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ILDM_UNKNOWN" => Some(Self::IldmUnknown),
            "ILDM_NORMAL" => Some(Self::IldmNormal),
            "ILDM_DIMMED" => Some(Self::IldmDimmed),
            "ILDM_HIDDEN" => Some(Self::IldmHidden),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetColorDisplayMode {
    NcdmUnknown = 0,
    /// Net and netclass colors are shown in the ratsnest and on all copper items
    NcdmAll = 1,
    /// Net and netclass colors are shown in the ratsnest only
    NcdmRatsnest = 2,
    /// Net and netclass colors are not shown
    NcdmOff = 3,
}
impl NetColorDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NcdmUnknown => "NCDM_UNKNOWN",
            Self::NcdmAll => "NCDM_ALL",
            Self::NcdmRatsnest => "NCDM_RATSNEST",
            Self::NcdmOff => "NCDM_OFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NCDM_UNKNOWN" => Some(Self::NcdmUnknown),
            "NCDM_ALL" => Some(Self::NcdmAll),
            "NCDM_RATSNEST" => Some(Self::NcdmRatsnest),
            "NCDM_OFF" => Some(Self::NcdmOff),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoardFlipMode {
    BfmUnknown = 0,
    /// Normal ("non-flipped") mode
    BfmNormal = 1,
    /// "Flipped" mode, viewed from the back and mirrored around the X axis
    BfmFlippedX = 2,
}
impl BoardFlipMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BfmUnknown => "BFM_UNKNOWN",
            Self::BfmNormal => "BFM_NORMAL",
            Self::BfmFlippedX => "BFM_FLIPPED_X",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BFM_UNKNOWN" => Some(Self::BfmUnknown),
            "BFM_NORMAL" => Some(Self::BfmNormal),
            "BFM_FLIPPED_X" => Some(Self::BfmFlippedX),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RatsnestDisplayMode {
    RdmUnknown = 0,
    /// Ratsnest lines are drawn to objects even if they are on hidden layers
    RdmAllLayers = 1,
    /// Ratsnest lines are hidden when at least one endpoint is an item on a hidden layer
    RdmVisibleLayers = 2,
}
impl RatsnestDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RdmUnknown => "RDM_UNKNOWN",
            Self::RdmAllLayers => "RDM_ALL_LAYERS",
            Self::RdmVisibleLayers => "RDM_VISIBLE_LAYERS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RDM_UNKNOWN" => Some(Self::RdmUnknown),
            "RDM_ALL_LAYERS" => Some(Self::RdmAllLayers),
            "RDM_VISIBLE_LAYERS" => Some(Self::RdmVisibleLayers),
            _ => None,
        }
    }
}
