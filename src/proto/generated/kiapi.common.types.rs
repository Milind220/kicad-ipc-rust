// This file is @generated by prost-build.
/// The set of object types (from KICAD_T) that are exposed to the API.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KiCadObjectType {
    KotUnknown = 0,
    KotPcbFootprint = 1,
    KotPcbPad = 2,
    KotPcbShape = 3,
    KotPcbReferenceImage = 4,
    KotPcbField = 5,
    KotPcbGenerator = 6,
    KotPcbText = 7,
    KotPcbTextbox = 8,
    KotPcbTable = 9,
    KotPcbTablecell = 10,
    KotPcbTrace = 11,
    KotPcbVia = 12,
    KotPcbArc = 13,
    KotPcbMarker = 14,
    KotPcbDimension = 15,
    KotPcbZone = 16,
    KotPcbGroup = 17,
    KotSchMarker = 18,
    KotSchJunction = 19,
    KotSchNoConnect = 20,
    KotSchBusWireEntry = 21,
    KotSchBusBusEntry = 22,
    KotSchLine = 23,
    KotSchShape = 24,
    KotSchBitmap = 25,
    KotSchTextbox = 26,
    KotSchText = 27,
    KotSchTable = 28,
    KotSchTablecell = 29,
    KotSchLabel = 30,
    KotSchGlobalLabel = 31,
    KotSchHierLabel = 32,
    KotSchDirectiveLabel = 33,
    KotSchField = 34,
    KotSchSymbol = 35,
    KotSchSheetPin = 36,
    KotSchSheet = 37,
    KotSchPin = 38,
    ///   KOT_LIB_SHAPE = 40;
    ///   KOT_LIB_TEXT = 41;
    ///   KOT_LIB_TEXTBOX = 42;
    ///   KOT_LIB_PIN = 43;
    ///   KOT_LIB_FIELD = 44;
    KotLibSymbol = 39,
    KotWsgLine = 45,
    KotWsgRect = 46,
    KotWsgPoly = 47,
    KotWsgText = 48,
    KotWsgBitmap = 49,
    KotWsgPage = 50,
    KotSchGroup = 51,
    KotPcbBarcode = 52,
}
impl KiCadObjectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KotUnknown => "KOT_UNKNOWN",
            Self::KotPcbFootprint => "KOT_PCB_FOOTPRINT",
            Self::KotPcbPad => "KOT_PCB_PAD",
            Self::KotPcbShape => "KOT_PCB_SHAPE",
            Self::KotPcbReferenceImage => "KOT_PCB_REFERENCE_IMAGE",
            Self::KotPcbField => "KOT_PCB_FIELD",
            Self::KotPcbGenerator => "KOT_PCB_GENERATOR",
            Self::KotPcbText => "KOT_PCB_TEXT",
            Self::KotPcbTextbox => "KOT_PCB_TEXTBOX",
            Self::KotPcbTable => "KOT_PCB_TABLE",
            Self::KotPcbTablecell => "KOT_PCB_TABLECELL",
            Self::KotPcbTrace => "KOT_PCB_TRACE",
            Self::KotPcbVia => "KOT_PCB_VIA",
            Self::KotPcbArc => "KOT_PCB_ARC",
            Self::KotPcbMarker => "KOT_PCB_MARKER",
            Self::KotPcbDimension => "KOT_PCB_DIMENSION",
            Self::KotPcbZone => "KOT_PCB_ZONE",
            Self::KotPcbGroup => "KOT_PCB_GROUP",
            Self::KotSchMarker => "KOT_SCH_MARKER",
            Self::KotSchJunction => "KOT_SCH_JUNCTION",
            Self::KotSchNoConnect => "KOT_SCH_NO_CONNECT",
            Self::KotSchBusWireEntry => "KOT_SCH_BUS_WIRE_ENTRY",
            Self::KotSchBusBusEntry => "KOT_SCH_BUS_BUS_ENTRY",
            Self::KotSchLine => "KOT_SCH_LINE",
            Self::KotSchShape => "KOT_SCH_SHAPE",
            Self::KotSchBitmap => "KOT_SCH_BITMAP",
            Self::KotSchTextbox => "KOT_SCH_TEXTBOX",
            Self::KotSchText => "KOT_SCH_TEXT",
            Self::KotSchTable => "KOT_SCH_TABLE",
            Self::KotSchTablecell => "KOT_SCH_TABLECELL",
            Self::KotSchLabel => "KOT_SCH_LABEL",
            Self::KotSchGlobalLabel => "KOT_SCH_GLOBAL_LABEL",
            Self::KotSchHierLabel => "KOT_SCH_HIER_LABEL",
            Self::KotSchDirectiveLabel => "KOT_SCH_DIRECTIVE_LABEL",
            Self::KotSchField => "KOT_SCH_FIELD",
            Self::KotSchSymbol => "KOT_SCH_SYMBOL",
            Self::KotSchSheetPin => "KOT_SCH_SHEET_PIN",
            Self::KotSchSheet => "KOT_SCH_SHEET",
            Self::KotSchPin => "KOT_SCH_PIN",
            Self::KotLibSymbol => "KOT_LIB_SYMBOL",
            Self::KotWsgLine => "KOT_WSG_LINE",
            Self::KotWsgRect => "KOT_WSG_RECT",
            Self::KotWsgPoly => "KOT_WSG_POLY",
            Self::KotWsgText => "KOT_WSG_TEXT",
            Self::KotWsgBitmap => "KOT_WSG_BITMAP",
            Self::KotWsgPage => "KOT_WSG_PAGE",
            Self::KotSchGroup => "KOT_SCH_GROUP",
            Self::KotPcbBarcode => "KOT_PCB_BARCODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KOT_UNKNOWN" => Some(Self::KotUnknown),
            "KOT_PCB_FOOTPRINT" => Some(Self::KotPcbFootprint),
            "KOT_PCB_PAD" => Some(Self::KotPcbPad),
            "KOT_PCB_SHAPE" => Some(Self::KotPcbShape),
            "KOT_PCB_REFERENCE_IMAGE" => Some(Self::KotPcbReferenceImage),
            "KOT_PCB_FIELD" => Some(Self::KotPcbField),
            "KOT_PCB_GENERATOR" => Some(Self::KotPcbGenerator),
            "KOT_PCB_TEXT" => Some(Self::KotPcbText),
            "KOT_PCB_TEXTBOX" => Some(Self::KotPcbTextbox),
            "KOT_PCB_TABLE" => Some(Self::KotPcbTable),
            "KOT_PCB_TABLECELL" => Some(Self::KotPcbTablecell),
            "KOT_PCB_TRACE" => Some(Self::KotPcbTrace),
            "KOT_PCB_VIA" => Some(Self::KotPcbVia),
            "KOT_PCB_ARC" => Some(Self::KotPcbArc),
            "KOT_PCB_MARKER" => Some(Self::KotPcbMarker),
            "KOT_PCB_DIMENSION" => Some(Self::KotPcbDimension),
            "KOT_PCB_ZONE" => Some(Self::KotPcbZone),
            "KOT_PCB_GROUP" => Some(Self::KotPcbGroup),
            "KOT_SCH_MARKER" => Some(Self::KotSchMarker),
            "KOT_SCH_JUNCTION" => Some(Self::KotSchJunction),
            "KOT_SCH_NO_CONNECT" => Some(Self::KotSchNoConnect),
            "KOT_SCH_BUS_WIRE_ENTRY" => Some(Self::KotSchBusWireEntry),
            "KOT_SCH_BUS_BUS_ENTRY" => Some(Self::KotSchBusBusEntry),
            "KOT_SCH_LINE" => Some(Self::KotSchLine),
            "KOT_SCH_SHAPE" => Some(Self::KotSchShape),
            "KOT_SCH_BITMAP" => Some(Self::KotSchBitmap),
            "KOT_SCH_TEXTBOX" => Some(Self::KotSchTextbox),
            "KOT_SCH_TEXT" => Some(Self::KotSchText),
            "KOT_SCH_TABLE" => Some(Self::KotSchTable),
            "KOT_SCH_TABLECELL" => Some(Self::KotSchTablecell),
            "KOT_SCH_LABEL" => Some(Self::KotSchLabel),
            "KOT_SCH_GLOBAL_LABEL" => Some(Self::KotSchGlobalLabel),
            "KOT_SCH_HIER_LABEL" => Some(Self::KotSchHierLabel),
            "KOT_SCH_DIRECTIVE_LABEL" => Some(Self::KotSchDirectiveLabel),
            "KOT_SCH_FIELD" => Some(Self::KotSchField),
            "KOT_SCH_SYMBOL" => Some(Self::KotSchSymbol),
            "KOT_SCH_SHEET_PIN" => Some(Self::KotSchSheetPin),
            "KOT_SCH_SHEET" => Some(Self::KotSchSheet),
            "KOT_SCH_PIN" => Some(Self::KotSchPin),
            "KOT_LIB_SYMBOL" => Some(Self::KotLibSymbol),
            "KOT_WSG_LINE" => Some(Self::KotWsgLine),
            "KOT_WSG_RECT" => Some(Self::KotWsgRect),
            "KOT_WSG_POLY" => Some(Self::KotWsgPoly),
            "KOT_WSG_TEXT" => Some(Self::KotWsgText),
            "KOT_WSG_BITMAP" => Some(Self::KotWsgBitmap),
            "KOT_WSG_PAGE" => Some(Self::KotWsgPage),
            "KOT_SCH_GROUP" => Some(Self::KotSchGroup),
            "KOT_PCB_BARCODE" => Some(Self::KotPcbBarcode),
            _ => None,
        }
    }
}
/// Mapped to GR_TEXT_H_ALIGN_T
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HorizontalAlignment {
    HaUnknown = 0,
    HaLeft = 1,
    HaCenter = 2,
    HaRight = 3,
    HaIndeterminate = 4,
}
impl HorizontalAlignment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HaUnknown => "HA_UNKNOWN",
            Self::HaLeft => "HA_LEFT",
            Self::HaCenter => "HA_CENTER",
            Self::HaRight => "HA_RIGHT",
            Self::HaIndeterminate => "HA_INDETERMINATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HA_UNKNOWN" => Some(Self::HaUnknown),
            "HA_LEFT" => Some(Self::HaLeft),
            "HA_CENTER" => Some(Self::HaCenter),
            "HA_RIGHT" => Some(Self::HaRight),
            "HA_INDETERMINATE" => Some(Self::HaIndeterminate),
            _ => None,
        }
    }
}
/// Mapped to GR_TEXT_V_ALIGN_T
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerticalAlignment {
    VaUnknown = 0,
    VaTop = 1,
    VaCenter = 2,
    VaBottom = 3,
    VaIndeterminate = 4,
}
impl VerticalAlignment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VaUnknown => "VA_UNKNOWN",
            Self::VaTop => "VA_TOP",
            Self::VaCenter => "VA_CENTER",
            Self::VaBottom => "VA_BOTTOM",
            Self::VaIndeterminate => "VA_INDETERMINATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VA_UNKNOWN" => Some(Self::VaUnknown),
            "VA_TOP" => Some(Self::VaTop),
            "VA_CENTER" => Some(Self::VaCenter),
            "VA_BOTTOM" => Some(Self::VaBottom),
            "VA_INDETERMINATE" => Some(Self::VaIndeterminate),
            _ => None,
        }
    }
}
/// Mapped to LINE_STYLE
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StrokeLineStyle {
    SlsUnknown = 0,
    SlsDefault = 1,
    SlsSolid = 2,
    SlsDash = 3,
    SlsDot = 4,
    SlsDashdot = 5,
    SlsDashdotdot = 6,
}
impl StrokeLineStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SlsUnknown => "SLS_UNKNOWN",
            Self::SlsDefault => "SLS_DEFAULT",
            Self::SlsSolid => "SLS_SOLID",
            Self::SlsDash => "SLS_DASH",
            Self::SlsDot => "SLS_DOT",
            Self::SlsDashdot => "SLS_DASHDOT",
            Self::SlsDashdotdot => "SLS_DASHDOTDOT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SLS_UNKNOWN" => Some(Self::SlsUnknown),
            "SLS_DEFAULT" => Some(Self::SlsDefault),
            "SLS_SOLID" => Some(Self::SlsSolid),
            "SLS_DASH" => Some(Self::SlsDash),
            "SLS_DOT" => Some(Self::SlsDot),
            "SLS_DASHDOT" => Some(Self::SlsDashdot),
            "SLS_DASHDOTDOT" => Some(Self::SlsDashdotdot),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommandStatusResponse {
    #[prost(enumeration = "CommandStatus", tag = "1")]
    pub status: i32,
}
/// *
/// Describes a particular version of KiCad
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KiCadVersion {
    #[prost(uint32, tag = "1")]
    pub major: u32,
    #[prost(uint32, tag = "2")]
    pub minor: u32,
    #[prost(uint32, tag = "3")]
    pub patch: u32,
    /// Full identifier string, potentially containing git hashes, packager-added info, etc.
    #[prost(string, tag = "4")]
    pub full_version: ::prost::alloc::string::String,
}
/// *
/// Describes a KIID, or UUID of an object in a KiCad editor model.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Kiid {
    /// The KIID's value in standard UUID format, stored as a string for easy portability
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
/// *
/// Describes a KiCad LIB_ID; a unique identifier for a loaded symbol or footprint
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LibraryIdentifier {
    /// The library portion of the LIB_ID
    #[prost(string, tag = "1")]
    pub library_nickname: ::prost::alloc::string::String,
    /// The symbol or footprint name
    #[prost(string, tag = "2")]
    pub entry_name: ::prost::alloc::string::String,
}
/// *
/// Describes a unique sheet in a schematic
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SheetPath {
    /// The canonical path to the sheet.  The first KIID will be the root sheet, etc.
    #[prost(message, repeated, tag = "1")]
    pub path: ::prost::alloc::vec::Vec<Kiid>,
    /// The path converted to a human readable form such as "/", "/child", or "/child/grandchild"
    #[prost(string, tag = "2")]
    pub path_human_readable: ::prost::alloc::string::String,
}
/// *
/// Describes a KiCad project
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProjectSpecifier {
    /// The name of the project (without the kicad_pro extension)
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The path to the project directory
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// *
/// Describes a document that will be the target of a request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentSpecifier {
    #[prost(enumeration = "DocumentType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "5")]
    pub project: ::core::option::Option<ProjectSpecifier>,
    #[prost(oneof = "document_specifier::Identifier", tags = "2, 3, 4")]
    pub identifier: ::core::option::Option<document_specifier::Identifier>,
}
/// Nested message and enum types in `DocumentSpecifier`.
pub mod document_specifier {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// If type == DT_SYMBOL or DT_FOOTPRINT, identifies a certain library entry
        #[prost(message, tag = "2")]
        LibId(super::LibraryIdentifier),
        /// If type == DT_SCHEMATIC, identifies a sheet with a given path
        #[prost(message, tag = "3")]
        SheetPath(super::SheetPath),
        /// If type == DT_PCB, identifies a PCB with a given filename, e.g. "board.kicad_pcb"
        #[prost(string, tag = "4")]
        BoardFilename(::prost::alloc::string::String),
    }
}
/// *
/// This header is included in requests and responses about item(s) in a document
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemHeader {
    /// Which document is this request targeting?
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<DocumentSpecifier>,
    /// Which container within the document is this request targeting?
    /// If container is omitted or empty, the document is used as the container.
    #[prost(message, optional, tag = "2")]
    pub container: ::core::option::Option<Kiid>,
    /// Which fields on the item(s) are included with this request or response
    #[prost(message, optional, tag = "3")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Describes a point or distance in 2D space.  All coordinates are in nanometers.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Vector2 {
    #[prost(int64, tag = "1")]
    pub x_nm: i64,
    #[prost(int64, tag = "2")]
    pub y_nm: i64,
}
/// Describes a point or distance in 3D space.  All coordinates are in nanometers.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Vector3 {
    #[prost(int64, tag = "1")]
    pub x_nm: i64,
    #[prost(int64, tag = "2")]
    pub y_nm: i64,
    #[prost(int64, tag = "3")]
    pub z_nm: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector3D {
    #[prost(double, tag = "1")]
    pub x_nm: f64,
    #[prost(double, tag = "2")]
    pub y_nm: f64,
    #[prost(double, tag = "3")]
    pub z_nm: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Box2 {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub size: ::core::option::Option<Vector2>,
}
/// Describes a quantity of distance (size, length, etc).  All coordinates are in nanometers.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Distance {
    #[prost(int64, tag = "1")]
    pub value_nm: i64,
}
/// Corresponds to EDA_ANGLE, where the underlying storage is degrees
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Angle {
    #[prost(double, tag = "1")]
    pub value_degrees: f64,
}
/// Represents a value from 0.0 to 1.0
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ratio {
    #[prost(double, tag = "1")]
    pub value: f64,
}
/// Represents a time delay in attoseconds. Since 10.0.0.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Time {
    #[prost(int64, tag = "1")]
    pub value_as: i64,
}
/// Corresponds to COLOR4D.  Each color channel is a double from 0.0 to 1.0.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Color {
    #[prost(double, tag = "1")]
    pub r: f64,
    #[prost(double, tag = "2")]
    pub g: f64,
    #[prost(double, tag = "3")]
    pub b: f64,
    #[prost(double, tag = "4")]
    pub a: f64,
}
/// The formulation of arc that is used in KiCad core geometry code.
/// Start, midpoint (on the arc) and end are stored.  Angle, center point, etc are calculated.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArcStartMidEnd {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub mid: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<Vector2>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PolyLineNode {
    #[prost(oneof = "poly_line_node::Geometry", tags = "1, 2")]
    pub geometry: ::core::option::Option<poly_line_node::Geometry>,
}
/// Nested message and enum types in `PolyLineNode`.
pub mod poly_line_node {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Geometry {
        #[prost(message, tag = "1")]
        Point(super::Vector2),
        #[prost(message, tag = "2")]
        Arc(super::ArcStartMidEnd),
    }
}
/// Corresponds to class SHAPE_LINE_CHAIN: A closed or open polyline that can include arcs.
/// For non-arc cases, each node is a point along the line.  An implicit line segment exists
/// between the last and first node if closed is true.  When arcs are present, the arc start and
/// end points are not duplicated by point nodes (meaning, for example, a rectangle with rounded
/// corners could be represented with four arc nodes and no point nodes).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolyLine {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<PolyLineNode>,
    #[prost(bool, tag = "2")]
    pub closed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolygonWithHoles {
    #[prost(message, optional, tag = "1")]
    pub outline: ::core::option::Option<PolyLine>,
    #[prost(message, repeated, tag = "2")]
    pub holes: ::prost::alloc::vec::Vec<PolyLine>,
}
/// Corresponds to SHAPE_POLY_SET: a set of polygons or polylines
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolySet {
    #[prost(message, repeated, tag = "1")]
    pub polygons: ::prost::alloc::vec::Vec<PolygonWithHoles>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextAttributes {
    #[prost(string, tag = "1")]
    pub font_name: ::prost::alloc::string::String,
    #[prost(enumeration = "HorizontalAlignment", tag = "2")]
    pub horizontal_alignment: i32,
    #[prost(enumeration = "VerticalAlignment", tag = "3")]
    pub vertical_alignment: i32,
    #[prost(message, optional, tag = "4")]
    pub angle: ::core::option::Option<Angle>,
    #[prost(double, tag = "5")]
    pub line_spacing: f64,
    #[prost(message, optional, tag = "6")]
    pub stroke_width: ::core::option::Option<Distance>,
    #[prost(bool, tag = "7")]
    pub italic: bool,
    #[prost(bool, tag = "8")]
    pub bold: bool,
    #[prost(bool, tag = "9")]
    pub underlined: bool,
    /// Deprecated since 9.0.1 (text items are now always visible, only Fields can be hidden)
    #[prost(bool, tag = "10")]
    pub visible: bool,
    #[prost(bool, tag = "11")]
    pub mirrored: bool,
    #[prost(bool, tag = "12")]
    pub multiline: bool,
    #[prost(bool, tag = "13")]
    pub keep_upright: bool,
    #[prost(message, optional, tag = "14")]
    pub size: ::core::option::Option<Vector2>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Text {
    /// Reserved for future use; base text objects don't have IDs right now
    /// kiapi.common.types.KIID           id         = 1;
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<TextAttributes>,
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub hyperlink: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextBox {
    #[prost(message, optional, tag = "2")]
    pub top_left: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub bottom_right: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "4")]
    pub attributes: ::core::option::Option<TextAttributes>,
    #[prost(string, tag = "6")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StrokeAttributes {
    #[prost(message, optional, tag = "1")]
    pub width: ::core::option::Option<Distance>,
    #[prost(enumeration = "StrokeLineStyle", tag = "2")]
    pub style: i32,
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GraphicFillAttributes {
    #[prost(enumeration = "GraphicFillType", tag = "1")]
    pub fill_type: i32,
    /// Color of the fill (not used in board and footprints)
    #[prost(message, optional, tag = "2")]
    pub color: ::core::option::Option<Color>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GraphicAttributes {
    #[prost(message, optional, tag = "1")]
    pub stroke: ::core::option::Option<StrokeAttributes>,
    #[prost(message, optional, tag = "2")]
    pub fill: ::core::option::Option<GraphicFillAttributes>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicSegmentAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<Vector2>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicRectangleAttributes {
    #[prost(message, optional, tag = "1")]
    pub top_left: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub bottom_right: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub corner_radius: ::core::option::Option<Distance>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicArcAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub mid: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<Vector2>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicCircleAttributes {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector2>,
    /// A point on the radius of the circle.  This is stored instead of just a radius so that the point
    /// by which the user can adjust the circle radius is persisted.
    #[prost(message, optional, tag = "2")]
    pub radius_point: ::core::option::Option<Vector2>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicBezierAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "2")]
    pub control1: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "3")]
    pub control2: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<Vector2>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicShape {
    /// Reserved for future use; base EDA_SHAPE doesn't have an ID or locked state right now
    /// KIID              id         = 1;
    /// LockedState       locked     = 2;
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<GraphicAttributes>,
    #[prost(oneof = "graphic_shape::Geometry", tags = "4, 5, 6, 7, 8, 9")]
    pub geometry: ::core::option::Option<graphic_shape::Geometry>,
}
/// Nested message and enum types in `GraphicShape`.
pub mod graphic_shape {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Geometry {
        #[prost(message, tag = "4")]
        Segment(super::GraphicSegmentAttributes),
        #[prost(message, tag = "5")]
        Rectangle(super::GraphicRectangleAttributes),
        #[prost(message, tag = "6")]
        Arc(super::GraphicArcAttributes),
        #[prost(message, tag = "7")]
        Circle(super::GraphicCircleAttributes),
        #[prost(message, tag = "8")]
        Polygon(super::PolySet),
        #[prost(message, tag = "9")]
        Bezier(super::GraphicBezierAttributes),
    }
}
/// A SHAPE_COMPOUND in KiCad
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompoundShape {
    #[prost(message, repeated, tag = "1")]
    pub shapes: ::prost::alloc::vec::Vec<GraphicShape>,
}
/// The text strings that can be set in a drawing sheet for the title block
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TitleBlockInfo {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub revision: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub company: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub comment1: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub comment2: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub comment3: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub comment4: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub comment5: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub comment6: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub comment7: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub comment8: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub comment9: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandStatus {
    CsUnknown = 0,
    /// Command succeeded
    CsOk = 1,
    /// Command failed
    CsFailed = 2,
}
impl CommandStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CsUnknown => "CS_UNKNOWN",
            Self::CsOk => "CS_OK",
            Self::CsFailed => "CS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CS_UNKNOWN" => Some(Self::CsUnknown),
            "CS_OK" => Some(Self::CsOk),
            "CS_FAILED" => Some(Self::CsFailed),
            _ => None,
        }
    }
}
/// *
/// Some commands are specific to a KiCad window (frame).  This list contains all addressable frames.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameType {
    FtUnknown = 0,
    FtProjectManager = 1,
    FtSchematicEditor = 2,
    FtPcbEditor = 3,
    FtSpiceSimulator = 4,
    FtSymbolEditor = 5,
    FtFootprintEditor = 6,
    FtDrawingSheetEditor = 7,
}
impl FrameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FtUnknown => "FT_UNKNOWN",
            Self::FtProjectManager => "FT_PROJECT_MANAGER",
            Self::FtSchematicEditor => "FT_SCHEMATIC_EDITOR",
            Self::FtPcbEditor => "FT_PCB_EDITOR",
            Self::FtSpiceSimulator => "FT_SPICE_SIMULATOR",
            Self::FtSymbolEditor => "FT_SYMBOL_EDITOR",
            Self::FtFootprintEditor => "FT_FOOTPRINT_EDITOR",
            Self::FtDrawingSheetEditor => "FT_DRAWING_SHEET_EDITOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FT_UNKNOWN" => Some(Self::FtUnknown),
            "FT_PROJECT_MANAGER" => Some(Self::FtProjectManager),
            "FT_SCHEMATIC_EDITOR" => Some(Self::FtSchematicEditor),
            "FT_PCB_EDITOR" => Some(Self::FtPcbEditor),
            "FT_SPICE_SIMULATOR" => Some(Self::FtSpiceSimulator),
            "FT_SYMBOL_EDITOR" => Some(Self::FtSymbolEditor),
            "FT_FOOTPRINT_EDITOR" => Some(Self::FtFootprintEditor),
            "FT_DRAWING_SHEET_EDITOR" => Some(Self::FtDrawingSheetEditor),
            _ => None,
        }
    }
}
/// *
/// Identifier for the type of document being targeted by a request
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DocumentType {
    DoctypeUnknown = 0,
    DoctypeSchematic = 1,
    DoctypeSymbol = 2,
    DoctypePcb = 3,
    DoctypeFootprint = 4,
    DoctypeDrawingSheet = 5,
    DoctypeProject = 6,
}
impl DocumentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DoctypeUnknown => "DOCTYPE_UNKNOWN",
            Self::DoctypeSchematic => "DOCTYPE_SCHEMATIC",
            Self::DoctypeSymbol => "DOCTYPE_SYMBOL",
            Self::DoctypePcb => "DOCTYPE_PCB",
            Self::DoctypeFootprint => "DOCTYPE_FOOTPRINT",
            Self::DoctypeDrawingSheet => "DOCTYPE_DRAWING_SHEET",
            Self::DoctypeProject => "DOCTYPE_PROJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOCTYPE_UNKNOWN" => Some(Self::DoctypeUnknown),
            "DOCTYPE_SCHEMATIC" => Some(Self::DoctypeSchematic),
            "DOCTYPE_SYMBOL" => Some(Self::DoctypeSymbol),
            "DOCTYPE_PCB" => Some(Self::DoctypePcb),
            "DOCTYPE_FOOTPRINT" => Some(Self::DoctypeFootprint),
            "DOCTYPE_DRAWING_SHEET" => Some(Self::DoctypeDrawingSheet),
            "DOCTYPE_PROJECT" => Some(Self::DoctypeProject),
            _ => None,
        }
    }
}
/// *
/// Status of a request that included an ItemHeader
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemRequestStatus {
    IrsUnknown = 0,
    IrsOk = 1,
    /// The given document is not open in KiCad
    IrsDocumentNotFound = 2,
    /// The given field_mask contains invalid specifiers
    IrsFieldMaskInvalid = 3,
}
impl ItemRequestStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::IrsUnknown => "IRS_UNKNOWN",
            Self::IrsOk => "IRS_OK",
            Self::IrsDocumentNotFound => "IRS_DOCUMENT_NOT_FOUND",
            Self::IrsFieldMaskInvalid => "IRS_FIELD_MASK_INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IRS_UNKNOWN" => Some(Self::IrsUnknown),
            "IRS_OK" => Some(Self::IrsOk),
            "IRS_DOCUMENT_NOT_FOUND" => Some(Self::IrsDocumentNotFound),
            "IRS_FIELD_MASK_INVALID" => Some(Self::IrsFieldMaskInvalid),
            _ => None,
        }
    }
}
/// Describes whether or not an item is locked for editing or movement
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockedState {
    LsUnknown = 0,
    LsUnlocked = 1,
    LsLocked = 2,
}
impl LockedState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LsUnknown => "LS_UNKNOWN",
            Self::LsUnlocked => "LS_UNLOCKED",
            Self::LsLocked => "LS_LOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LS_UNKNOWN" => Some(Self::LsUnknown),
            "LS_UNLOCKED" => Some(Self::LsUnlocked),
            "LS_LOCKED" => Some(Self::LsLocked),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphicFillType {
    GftUnknown = 0,
    GftUnfilled = 1,
    GftFilled = 2,
}
impl GraphicFillType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GftUnknown => "GFT_UNKNOWN",
            Self::GftUnfilled => "GFT_UNFILLED",
            Self::GftFilled => "GFT_FILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GFT_UNKNOWN" => Some(Self::GftUnknown),
            "GFT_UNFILLED" => Some(Self::GftUnfilled),
            "GFT_FILLED" => Some(Self::GftFilled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AxisAlignment {
    AaUnknown = 0,
    AaXAxis = 1,
    AaYAxis = 2,
}
impl AxisAlignment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AaUnknown => "AA_UNKNOWN",
            Self::AaXAxis => "AA_X_AXIS",
            Self::AaYAxis => "AA_Y_AXIS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AA_UNKNOWN" => Some(Self::AaUnknown),
            "AA_X_AXIS" => Some(Self::AaXAxis),
            "AA_Y_AXIS" => Some(Self::AaYAxis),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MapMergeMode {
    MmmUnknown = 0,
    /// The existing map will be merged with the incoming map; keys that are not present in the
    /// incoming map will be preserved with their original values
    MmmMerge = 1,
    /// The existing map will be cleared and replaced with the incoming map
    MmmReplace = 2,
}
impl MapMergeMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MmmUnknown => "MMM_UNKNOWN",
            Self::MmmMerge => "MMM_MERGE",
            Self::MmmReplace => "MMM_REPLACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MMM_UNKNOWN" => Some(Self::MmmUnknown),
            "MMM_MERGE" => Some(Self::MmmMerge),
            "MMM_REPLACE" => Some(Self::MmmReplace),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ElectricalPinType {
    EptUnknown = 0,
    EptInput = 1,
    EptOutput = 2,
    EptBidirectional = 3,
    EptTristate = 4,
    EptPassive = 5,
    /// A free pin is not internally connected and may connect to any net (route-through)
    EptFree = 6,
    EptUnspecified = 7,
    EptPowerInput = 8,
    EptPowerOutput = 9,
    EptOpenCollector = 10,
    EptOpenEmitter = 11,
    /// A no-connect pin should not be connected to any net
    EptNoConnect = 12,
}
impl ElectricalPinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EptUnknown => "EPT_UNKNOWN",
            Self::EptInput => "EPT_INPUT",
            Self::EptOutput => "EPT_OUTPUT",
            Self::EptBidirectional => "EPT_BIDIRECTIONAL",
            Self::EptTristate => "EPT_TRISTATE",
            Self::EptPassive => "EPT_PASSIVE",
            Self::EptFree => "EPT_FREE",
            Self::EptUnspecified => "EPT_UNSPECIFIED",
            Self::EptPowerInput => "EPT_POWER_INPUT",
            Self::EptPowerOutput => "EPT_POWER_OUTPUT",
            Self::EptOpenCollector => "EPT_OPEN_COLLECTOR",
            Self::EptOpenEmitter => "EPT_OPEN_EMITTER",
            Self::EptNoConnect => "EPT_NO_CONNECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EPT_UNKNOWN" => Some(Self::EptUnknown),
            "EPT_INPUT" => Some(Self::EptInput),
            "EPT_OUTPUT" => Some(Self::EptOutput),
            "EPT_BIDIRECTIONAL" => Some(Self::EptBidirectional),
            "EPT_TRISTATE" => Some(Self::EptTristate),
            "EPT_PASSIVE" => Some(Self::EptPassive),
            "EPT_FREE" => Some(Self::EptFree),
            "EPT_UNSPECIFIED" => Some(Self::EptUnspecified),
            "EPT_POWER_INPUT" => Some(Self::EptPowerInput),
            "EPT_POWER_OUTPUT" => Some(Self::EptPowerOutput),
            "EPT_OPEN_COLLECTOR" => Some(Self::EptOpenCollector),
            "EPT_OPEN_EMITTER" => Some(Self::EptOpenEmitter),
            "EPT_NO_CONNECT" => Some(Self::EptNoConnect),
            _ => None,
        }
    }
}
