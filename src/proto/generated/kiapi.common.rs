// This file is @generated by prost-build.
///
/// For future expansion: any header fields that should be sent with a request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiRequestHeader {
    /// An opaque string identifying a running instance of KiCad.  If this is set to a non-empty
    /// string in an API request, KiCad will reject the request if the value doesn't match its own
    /// token.  This can be used to let API clients make sure they are still talking to the same
    /// instance of KiCad if they are long-running.
    #[prost(string, tag = "1")]
    pub kicad_token: ::prost::alloc::string::String,
    /// A string identifying an API client.  Should be set by the client to a value that is unique
    /// to a specific instance of a client, for example the package name of the client plus its
    /// process ID or a random string, e.g. "com.github.me.my_awesome_plugin-73951".  The main purpose
    /// of this name is to identify the client in debug logs.
    #[prost(string, tag = "2")]
    pub client_name: ::prost::alloc::string::String,
}
///
/// The top-level envelope container for an API request (message from a client to the KiCad API server)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiRequest {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<ApiRequestHeader>,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<::prost_types::Any>,
}
///
/// For future expansion: any header fields that should be sent with a response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiResponseHeader {
    /// / An opaque string identifying a running instance of KiCad.
    #[prost(string, tag = "1")]
    pub kicad_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiResponse {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<ApiResponseHeader>,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<ApiResponseStatus>,
    #[prost(message, optional, tag = "3")]
    pub message: ::core::option::Option<::prost_types::Any>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiResponseStatus {
    /// / A code describing the category of error (or AS_OK if no error)
    #[prost(enumeration = "ApiStatusCode", tag = "1")]
    pub status: i32,
    /// / A human-readable description of the error, if any
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApiStatusCode {
    AsUnknown = 0,
    /// Request succeeded
    AsOk = 1,
    /// Request timed out
    AsTimeout = 2,
    /// The request had invalid parameters or otherwise was illegal
    AsBadRequest = 3,
    /// KiCad has recently started and cannot handle API requests yet
    AsNotReady = 4,
    /// The request was not handled by KiCad
    AsUnhandled = 5,
    /// The kicad_token in the request didn't match this KiCad's token
    AsTokenMismatch = 6,
    /// KiCad is busy performing an operation and can't accept API commands
    AsBusy = 7,
    /// The requested API call has not yet been implemented
    AsUnimplemented = 8,
}
impl ApiStatusCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AsUnknown => "AS_UNKNOWN",
            Self::AsOk => "AS_OK",
            Self::AsTimeout => "AS_TIMEOUT",
            Self::AsBadRequest => "AS_BAD_REQUEST",
            Self::AsNotReady => "AS_NOT_READY",
            Self::AsUnhandled => "AS_UNHANDLED",
            Self::AsTokenMismatch => "AS_TOKEN_MISMATCH",
            Self::AsBusy => "AS_BUSY",
            Self::AsUnimplemented => "AS_UNIMPLEMENTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AS_UNKNOWN" => Some(Self::AsUnknown),
            "AS_OK" => Some(Self::AsOk),
            "AS_TIMEOUT" => Some(Self::AsTimeout),
            "AS_BAD_REQUEST" => Some(Self::AsBadRequest),
            "AS_NOT_READY" => Some(Self::AsNotReady),
            "AS_UNHANDLED" => Some(Self::AsUnhandled),
            "AS_TOKEN_MISMATCH" => Some(Self::AsTokenMismatch),
            "AS_BUSY" => Some(Self::AsBusy),
            "AS_UNIMPLEMENTED" => Some(Self::AsUnimplemented),
            _ => None,
        }
    }
}
