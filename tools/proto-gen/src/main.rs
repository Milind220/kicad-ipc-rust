use std::env;
use std::ffi::OsStr;
use std::fs;
use std::io;
use std::path::{Path, PathBuf};
use std::process::Command;

fn collect_proto_files(root: &Path, out: &mut Vec<PathBuf>) -> io::Result<()> {
    for entry in fs::read_dir(root)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            collect_proto_files(&path, out)?;
            continue;
        }

        if path.extension() == Some(OsStr::new("proto")) {
            out.push(path);
        }
    }

    Ok(())
}

fn remove_generated_files(output_dir: &Path) -> io::Result<()> {
    if !output_dir.exists() {
        return Ok(());
    }

    for entry in fs::read_dir(output_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let Some(name) = path.file_name().and_then(|n| n.to_str()) else {
            continue;
        };

        if name.starts_with("kiapi.") && name.ends_with(".rs") {
            fs::remove_file(path)?;
        }
    }

    Ok(())
}

fn detect_kicad_api_version(submodule_dir: &Path) -> String {
    let output = Command::new("git")
        .arg("describe")
        .arg("--long")
        .current_dir(submodule_dir)
        .output();

    match output {
        Ok(out) if out.status.success() => {
            String::from_utf8_lossy(&out.stdout).trim().to_owned()
        }
        _ => {
            let fallback = Command::new("git")
                .arg("rev-parse")
                .arg("--short")
                .arg("HEAD")
                .current_dir(submodule_dir)
                .output();

            match fallback {
                Ok(out) if out.status.success() => {
                    format!("rev-{}", String::from_utf8_lossy(&out.stdout).trim())
                }
                _ => "unknown".to_owned(),
            }
        }
    }
}

fn write_api_version(version_file: &Path, api_version: &str) -> io::Result<()> {
    let parent = version_file
        .parent()
        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "invalid version file path"))?;
    fs::create_dir_all(parent)?;

    let escaped = api_version.replace('"', "\\\"");
    let body = format!(
        "// Generated by tools/proto-gen.\npub const KICAD_API_VERSION: &str = \"{}\";\n",
        escaped
    );
    fs::write(version_file, body)
}

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let repo_root = manifest_dir
        .parent()
        .and_then(|p| p.parent())
        .expect("failed to find repo root")
        .to_path_buf();

    let proto_root = env::var_os("KICAD_PROTO_ROOT")
        .map(PathBuf::from)
        .unwrap_or_else(|| repo_root.join("kicad/api/proto"));

    if !proto_root.exists() {
        panic!(
            "KiCad proto root not found at '{}'. Run `git submodule update --init --recursive` or set KICAD_PROTO_ROOT.",
            proto_root.display()
        );
    }

    let output_dir = repo_root.join("src/proto/generated");
    fs::create_dir_all(&output_dir).expect("failed to create generated output directory");
    remove_generated_files(&output_dir).expect("failed to clear stale generated files");

    let mut proto_files = Vec::new();
    collect_proto_files(&proto_root, &mut proto_files)
        .unwrap_or_else(|err| panic!("failed to enumerate proto files: {err}"));
    proto_files.sort();

    let mut config = prost_build::Config::new();
    config.out_dir(&output_dir);
    config.protoc_arg("--experimental_allow_proto3_optional");

    config
        .compile_protos(&proto_files, &[proto_root.clone()])
        .expect("failed to compile KiCad protobuf schema");

    let kicad_submodule = proto_root
        .parent()
        .and_then(|p| p.parent())
        .expect("failed to locate KiCad submodule root")
        .to_path_buf();

    let api_version = detect_kicad_api_version(&kicad_submodule);
    let version_file = repo_root.join("src/kicad_api_version.rs");
    write_api_version(&version_file, &api_version).expect("failed to write API version file");

    println!("Generated protobuf bindings into {}", output_dir.display());
    println!("Updated API version: {}", api_version);
}
